<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Testing Suite</title>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow-x: hidden;
            background: #000000;
            font-size: 14px;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .page_wrap {
            position: relative;
            z-index: 10;
            pointer-events: auto;
        }
        
        .test-header {
            position: fixed;
            top: 24px;
            left: 24px;
            width: auto;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.98);
            padding: 24px 32px;
            border-radius: 20px;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.12),
                0 8px 16px rgba(0, 0, 0, 0.08),
                0 0 0 1px rgba(255, 255, 255, 0.05);
            z-index: 100;
            backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .test-header h1 {
            font-size: 28px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
        }
        
        .test-header p {
            color: #6b7280;
            font-size: 15px;
            font-weight: 400;
            line-height: 1.6;
            margin: 0;
        }
        
        .test-header p:last-child {
            margin-top: 4px;
            font-weight: 500;
            color: #374151;
        }
        
        .info-panels {
            position: fixed;
            bottom: 32px;
            left: 32px;
            display: flex;
            gap: 24px;
            z-index: 100;
            align-items: flex-end;
            /* Make gaps transparent to pointer events; panels explicitly re-enable */
            pointer-events: none;
        }
        .info-panels > .info-panel { pointer-events: auto; }
        /* Utility class to disable pass-through entirely if needed (toggle via JS) */
        .info-panels.no-pass-through { pointer-events: auto; }
        .info-panels.no-pass-through > .info-panel { pointer-events: auto; }
        /* Prevent accidental text selection while dragging over left-side panels */
        .info-panels, .info-panels .info-panel, .info-panels .info-panel *:not(input):not(textarea):not(select) {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        /* Allow normal selection/editing inside form fields */
        .info-panels input, .info-panels textarea, .info-panels select { 
            -webkit-user-select: text; 
            -moz-user-select: text; 
            -ms-user-select: text; 
            user-select: text; 
        }
        /* Allow text selection on copyable elements for fallback clipboard functionality */
        .info-panels .copyable {
            -webkit-user-select: text; 
            -moz-user-select: text; 
            -ms-user-select: text; 
            user-select: text; 
        }
        
        .info-panel {
            background: rgba(31, 41, 55, 0.85);
            color: #e5e7eb;
            padding: 28px 32px;
            border-radius: 16px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.7;
            flex: 1;
            width: auto;
            max-height: auto;
            overflow-y: auto;
            border: 1px solid rgba(75, 85, 99, 0.4);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.1, 1);
            transform-origin: bottom;
            backdrop-filter: blur(12px);
        }

        /* Specific sizing and ordering for panels */
        #camera-panel,
        #performance-panel {
            flex: 0 0 auto;
            width: 320px; /* default width */
            height: auto; /* dynamic height */
            max-height: 340px;
            overflow-y: auto; /* allow scroll if long */
        }
        /* Animation helper panel should expand to fit contents without its own scrollbar */
        #animation-helper-panel {
            flex: 0 0 auto;
            width: 320px;
            height: auto;
            max-height: none;
            overflow-y: visible;
        }

        #model-status-panel {
            flex: 0 0 auto;
            width: 420px; /* default width */
            height: 300px; /* fixed height to match others */
            max-height: 300px;
            overflow-y: hidden;
        }

        /* Make status the last panel in the row */
    #animation-helper-panel { order: 1; }
    #camera-panel { order: 2; }
    #performance-panel { order: 3; }
    #model-status-panel { order: 4; }
        
    
        
        .info-panel h3 {
            color: #f9fafb;
            margin-bottom: 20px;
            font-size: 15px;
            border-bottom: 2px solid rgba(107, 114, 128, 0.3);
            padding-bottom: 12px;
            font-weight: 700;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            letter-spacing: -0.2px;
            transition: color 0.3s ease;
            cursor: pointer;
        }
        
        .minimize-btn {
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            line-height: 1;
        }
        
        .minimize-btn:hover {
            background: rgba(156, 163, 175, 0.2);
            color: #d1d5db;
            transform: scale(1.1);
        }
        
        .panel-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .panel-content.minimized {
            height: 0 !important;
            max-height: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
            opacity: 0;
            overflow: hidden;
        }

        /* Animation Helper specific styles (Phase 1) */
        #animation-helper-panel .panel-content { display: flex; flex-direction: column; gap: 10px; }
    #animation-helper-panel .kf-buttons { display: flex; flex-wrap: wrap; gap: 6px; }
    #animation-helper-panel .kf-buttons .btn { flex: 1 1 auto; }
    #animation-helper-panel ul.keyframe-list { list-style: none; padding: 0; margin: 6px 0 0; font-size: 11px; line-height: 1.35; }
    #animation-helper-panel ul.keyframe-list li { padding: 6px 8px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1); border-radius: 5px; margin-bottom: 6px; display: flex; flex-direction: column; gap: 4px; position: relative; }
    #animation-helper-panel ul.keyframe-list li .kf-row { display: flex; justify-content: space-between; gap: 6px; align-items: center; }
    #animation-helper-panel ul.keyframe-list li span.meta { opacity: 0.7; font-size: 10px; }
    #animation-helper-panel ul.keyframe-list li button.remove-kf { background: none; border: none; color: #f87171; cursor: pointer; font-size: 14px; line-height: 1; padding: 2px 4px; }
    #animation-helper-panel ul.keyframe-list li button.remove-kf:hover { color: #dc2626; }
    #animation-helper-panel .segment-settings { display: flex; align-items: center; gap: 6px; font-size: 10px; }
    #animation-helper-panel .segment-settings input { width: 68px; padding: 2px 4px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.15); border-radius: 4px; color: #eee; font-size: 10px; }
    #animation-helper-panel .segment-settings input:focus { outline: none; border-color: #60a5fa; }
    #animation-helper-panel .playback-controls { display: flex; gap: 6px; }
    #animation-helper-panel .playback-row { display: flex; flex-direction: column; gap: 6px; }
    #animation-helper-panel .playback-progress { display: flex; align-items: center; gap: 6px; }
    #animation-helper-panel .playback-progress progress { flex: 1 1 auto; height: 8px; }
    #animation-helper-panel progress { width: 100%; }
    #animation-helper-panel .scrubber-row { display: flex; gap: 6px; align-items: center; }
    #animation-helper-panel .scrubber-row input[type=range] { flex: 1 1 auto; }
    #animation-helper-panel select#kf-ease { width: 100%; padding: 4px 6px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.15); color: #eee; border-radius: 4px; font-size: 11px; }
    #animation-helper-panel select#kf-ease:focus { outline: none; border-color: #60a5fa; }
        #animation-helper-panel .empty-state { font-size: 11px; opacity: 0.6; }
        #animation-helper-panel .status-line { font-size: 10px; opacity: 0.7; }
        #animation-helper-panel button.btn[disabled] { opacity: 0.4; cursor: not-allowed; }
    #animation-helper-panel .library-row { display:flex; gap:6px; margin-top:8px; }
    #animation-helper-panel .library-row input { flex:1 1 auto; padding:4px 6px; background: rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.15); color:#eee; border-radius:4px; font-size:11px; }
    #animation-helper-panel .library-row input:focus { outline:none; border-color:#60a5fa; }
    #animation-helper-panel .saved-animations { margin-top:8px; }
    #animation-helper-panel .saved-animations select { width:100%; padding:4px 6px; background: rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.15); color:#eee; border-radius:4px; font-size:11px; }
    #animation-helper-panel .saved-animations select:focus { outline:none; border-color:#60a5fa; }
    #animation-helper-panel .library-actions { display:flex; gap:6px; margin-top:6px; flex-wrap:wrap; }
    #animation-helper-panel .library-actions .btn { flex:1 1 auto; }
        
        .info-panel.minimized {
            min-height: auto;
            height: auto !important;
            padding: 12px 16px;
        }
        
        .info-panel.minimized h3 {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
            font-size: 13px;
        }
        
        .controls-panel.minimized {
            padding: 12px 16px;
        }
        
        .controls-panel.minimized h3 {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
            font-size: 16px;
        }
        
        .controls-panel.minimized .refresh-icon {
            width: 28px;
            height: 28px;
            font-size: 14px;
        }
        
        .controls-panel {
            background: rgba(31, 41, 55, 0.85);
            color: #e5e7eb;
            padding: 36px 40px;
            border-radius: 20px;
            width: 750px;
            position: fixed;
            bottom: 32px;
            right: 32px;
            z-index: 100;
            pointer-events: auto; /* Explicitly enable pointer events */
            backdrop-filter: blur(12px);
            border: 1px solid rgba(75, 85, 99, 0.4);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.2);
            max-height: calc(100vh - 220px);
            overflow-y: auto;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.1, 1);
        }
        
        .controls-panel h3 {
            color: #f9fafb;
            margin-bottom: 28px;
            font-size: 22px;
            font-weight: 800;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            border-bottom: 3px solid rgba(107, 114, 128, 0.3);
            padding-bottom: 16px;
            letter-spacing: -0.4px;
            position: relative;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
        }
        
        .controls-panel h3::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 40px;
            height: 3px;
            background: linear-gradient(90deg, #6b7280, #9ca3af);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Quick UI hide mode */
        body.ui-hidden .info-panels,
        body.ui-hidden .controls-panel,
        body.ui-hidden .test-header { display: none !important; }
        body.ui-hidden #toast { display: none !important; }
        body.ui-hidden::after {
            content: 'UI Hidden (press H to toggle)';
            position: fixed; top: 8px; right: 12px; z-index: 9999;
            background: rgba(0,0,0,0.5); color:#fff; font: 12px/1.4 -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
            padding: 6px 10px; border-radius: 6px; letter-spacing: .5px;
        }

        .controls-panel:hover h3::after {
            width: 80px;
        }
        
        .mode-toggle {
            margin-bottom: 28px;
            padding: 24px;
            background: rgba(55, 65, 81, 0.6);
            border-radius: 16px;
            border: 1px solid rgba(75, 85, 99, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
        }
        
        .mode-toggle:hover {
            background: rgba(55, 65, 81, 0.8);
            border-color: rgba(75, 85, 99, 0.6);
            transform: translateY(-1px);
        }
        
        .mode-toggle > div:first-child {
            font-size: 12px;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .toggle-switch {
            display: flex;
            background: rgba(17, 24, 39, 0.6);
            border-radius: 12px;
            padding: 4px;
            margin-top: 0;
        }

        .tips-box {
            margin-top: 12px;
            padding: 12px 14px;
            background: rgba(31, 41, 55, 0.5);
            border: 1px dashed rgba(156, 163, 175, 0.35);
            border-radius: 12px;
            color: #e5e7eb;
            font-size: 12px;
        }
        .tips-box b { color: #f9fafb; }
        .tips-box ul { margin: 6px 0 0 16px; }
        .tips-box li { margin: 4px 0; }
        
        .toggle-option {
            flex: 1;
            padding: 12px 16px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.1, 1);
            font-size: 13px;
            font-weight: 600;
            color: #6b7280;
            position: relative;
            overflow: hidden;
        }
        
        .toggle-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s ease;
        }
        
        .toggle-option:hover::before:not(.active) {
            left: 100%;
        }
        
        .toggle-option.active {
            background: #374151;
            color: white;
            box-shadow: 
                0 6px 16px rgba(55, 65, 81, 0.3),
                0 3px 6px rgba(55, 65, 81, 0.2);
            transform: translateY(-2px) scale(1.02);
            animation: activeGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes activeGlow {
            from {
                box-shadow: 
                    0 6px 16px rgba(31, 41, 55, 0.2),
                    0 3px 6px rgba(31, 41, 55, 0.15);
            }
            to {
                box-shadow: 
                    0 8px 20px rgba(31, 41, 55, 0.25),
                    0 4px 8px rgba(31, 41, 55, 0.2);
            }
        }
        
        .toggle-option:hover:not(.active) {
            background: rgba(243, 244, 246, 0.8);
            color: #374151;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .comparison-panel {
            display: none;
            margin-bottom: 28px;
            padding: 24px;
            background: rgba(243, 244, 246, 0.8);
            border-radius: 16px;
            border: 1px solid rgba(209, 213, 219, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
            animation: slideIn 0.4s ease-out when visible;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .model-selector {
            margin-bottom: 16px;
        }
        
        .model-selector label {
            display: block;
            font-size: 12px;
            margin-bottom: 8px;
            color: #4b5563;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .model-selector select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.9);
            color: #1f2937;
            border: 1px solid rgba(209, 213, 219, 0.6);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.1, 1);
            cursor: pointer;
            position: relative;
        }
        
        .model-selector select:focus {
            outline: none;
            border-color: #1f2937;
            box-shadow: 
                0 0 0 4px rgba(31, 41, 55, 0.1),
                0 4px 12px rgba(0, 0, 0, 0.08);
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
            animation: focusPulse 0.3s ease-out;
        }
        
        @keyframes focusPulse {
            0% {
                box-shadow: 
                    0 0 0 0 rgba(31, 41, 55, 0.4),
                    0 4px 12px rgba(0, 0, 0, 0.08);
            }
            50% {
                box-shadow: 
                    0 0 0 6px rgba(31, 41, 55, 0.2),
                    0 4px 12px rgba(0, 0, 0, 0.08);
            }
            100% {
                box-shadow: 
                    0 0 0 4px rgba(31, 41, 55, 0.1),
                    0 4px 12px rgba(0, 0, 0, 0.08);
            }
        }
        
        .model-selector select:hover {
            border-color: #9ca3af;
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .model-group {
            margin-bottom: 8px;
        }
        
        .model-group-label {
            font-size: 10px;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 8px 0 4px 0;
            padding-left: 4px;
        }
        
        .opacity-slider {
            margin: 20px 0;
            padding: 16px;
            background: rgba(229, 231, 235, 0.4);
            border-radius: 8px;
            border: 1px solid rgba(209, 213, 219, 0.3);
        }
        
        .opacity-slider > div:first-child {
            font-size: 12px;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 0;
        }
        
        .slider-label {
            font-size: 11px;
            color: #6b7280;
            min-width: 60px;
            font-weight: 600;
            text-align: center;
        }
        
        .slider {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #ef4444 0%, #06b6d4 100%);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .slider:hover {
            height: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.2),
                0 0 0 2px rgba(31, 41, 55, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
            position: relative;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.3),
                0 0 0 4px rgba(31, 41, 55, 0.2);
            animation: thumbPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes thumbPulse {
            0%, 100% {
                box-shadow: 
                    0 8px 16px rgba(0, 0, 0, 0.3),
                    0 0 0 4px rgba(31, 41, 55, 0.2);
            }
            50% {
                box-shadow: 
                    0 8px 16px rgba(0, 0, 0, 0.3),
                    0 0 0 6px rgba(31, 41, 55, 0.3);
            }
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.2),
                0 0 0 2px rgba(31, 41, 55, 0.1);
        }
        
        .comparison-controls {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }
        
        .comparison-controls .btn {
            flex: 1;
            padding: 10px 12px;
            font-size: 12px;
            margin: 0;
        }
        
        .model-group-label {
            font-size: 11px;
            color: #6b7280;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin: 16px 0 12px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(156, 163, 175, 0.2);
            position: relative;
            transition: all 0.3s ease;
        }
        
        .model-group-label:hover {
            color: #374151;
            letter-spacing: 1px;
            transform: translateX(2px);
        }
        
        .model-group-label::before {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 32px;
            height: 2px;
            background: #1f2937;
            border-radius: 1px;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.1, 1);
        }
        
        .model-group-label:hover::before {
            width: 60px;
        }
        
        .single-model-controls {
            display: block;
        }
        
        .models-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .model-group {
            display: flex;
            flex-direction: column;
        }
        
        .utility-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 6px;
            margin-top: 16px;
        }
        
        .refresh-icon {
            position: static;
            background: rgba(107, 114, 128, 0.1);
            border: 1px solid rgba(107, 114, 128, 0.2);
            color: #6b7280;
            width: 32px;
            height: 32px;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .refresh-icon:hover {
            background: rgba(107, 114, 128, 0.2);
            border-color: rgba(107, 114, 128, 0.4);
            transform: rotate(180deg) scale(1.1);
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn {
            background: #374151;
            color: #e5e7eb;
            border: none;
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            margin: 0 0 6px 0;
            display: block;
            width: 100%;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.1, 1);
            border: 1px solid rgba(75, 85, 99, 0.3);
            position: relative;
            overflow: hidden;
            letter-spacing: 0.2px;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .btn.neutral {
            background: #6b7280;
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .btn.neutral:hover {
            background: #9ca3af;
            box-shadow: 
                0 4px 12px rgba(107, 114, 128, 0.2),
                0 2px 4px rgba(107, 114, 128, 0.15);
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 8px 20px rgba(0, 0, 0, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.2);
            background: #4b5563;
            border-color: rgba(107, 114, 128, 0.4);
        }
        
        .btn:active {
            transform: translateY(-1px) scale(0.98);
            box-shadow: 
                0 4px 8px rgba(75, 85, 99, 0.2);
            transition: all 0.1s ease;
        }
        
        .btn.success { 
            background: #059669;
            border-color: rgba(255, 255, 255, 0.1);
        }
        .btn.success:hover { 
            background: #047857;
            box-shadow: 
                0 8px 20px rgba(5, 150, 105, 0.25),
                0 4px 8px rgba(5, 150, 105, 0.15);
        }
        
        .btn.warning { 
            background: #d97706;
            color: white;
            border-color: rgba(255, 255, 255, 0.1);
        }
        .btn.warning:hover { 
            background: #b45309;
            box-shadow: 
                0 8px 20px rgba(217, 119, 6, 0.25),
                0 4px 8px rgba(217, 119, 6, 0.15);
        }
        
        .btn.danger { 
            background: #dc2626;
            border-color: rgba(255, 255, 255, 0.1);
        }
        .btn.danger:hover { 
            background: #b91c1c;
            box-shadow: 
                0 8px 20px rgba(220, 38, 38, 0.25),
                0 4px 8px rgba(220, 38, 38, 0.15);
        }
        
        .comparison-controls .btn {
            font-size: 12px;
            padding: 10px 16px;
        }
        
        .camera-info {
            color: #e5e7eb;
            font-weight: 500;
        }
        
        .camera-info div {
            margin: 10px 0;
            padding: 6px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(156, 163, 175, 0.1);
            transition: all 0.2s ease;
        }
        
        .camera-info div:last-child {
            border-bottom: none;
        }
        
        .camera-info div:hover {
            background: rgba(243, 244, 246, 0.3);
            padding: 6px 8px;
            border-radius: 6px;
            margin: 10px -8px;
        }
        
        .camera-info span {
            font-weight: 600;
            color: #059669;
        }
        
        .performance-info {
            color: #e5e7eb;
            font-weight: 500;
        }
        
        .performance-info div {
            margin: 10px 0;
            padding: 6px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(156, 163, 175, 0.1);
            transition: all 0.2s ease;
        }
        
        .performance-info div:last-child {
            border-bottom: none;
        }
        
        .performance-info div:hover {
            background: rgba(243, 244, 246, 0.3);
            padding: 6px 8px;
            border-radius: 6px;
            margin: 10px -8px;
        }
        
        .performance-info span {
            font-weight: 600;
            color: #d97706;
        }
        
        .model-info {
            color: #1f2937;
            font-weight: 500;
        }
        
        /* Loading States */
        .loading-indicator {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2.5px solid rgba(31, 41, 55, 0.1);
            border-radius: 50%;
            border-top-color: #1f2937;
            animation: spin 1.2s cubic-bezier(0.4, 0, 0.1, 1) infinite;
            margin-right: 10px;
            position: relative;
        }
        
        .loading-indicator::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border: 1px solid transparent;
            border-top-color: rgba(31, 41, 55, 0.3);
            border-radius: 50%;
            animation: spin 0.8s linear infinite reverse;
        }
        
        @keyframes spin {
            0% { 
                transform: rotate(0deg); 
            }
            50% { 
                transform: rotate(180deg); 
                border-width: 3px;
            }
            100% { 
                transform: rotate(360deg); 
                border-width: 2.5px;
            }
        }
        
        .status-success {
            color: #059669;
            font-weight: 600;
        }
        
        .status-error {
            color: #dc2626;
            font-weight: 600;
        }
        
        .status-loading {
            color: #d97706;
            font-weight: 600;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(156, 163, 175, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #059669, #10b981, #06b6d4);
            border-radius: 3px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.1, 1);
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: progressShine 1.5s ease-in-out infinite;
        }
        
        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
            100% { transform: translateX(100%); }
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .info-panels {
                flex-direction: column;
                bottom: 16px;
                left: 16px;
                right: 16px;
                gap: 12px;
            }
            
            /* On small screens, let panels size naturally */
            #camera-panel,
            #performance-panel,
            #model-status-panel {
                width: auto;
                height: auto;
                max-height: none;
                order: initial;
                flex: 1 1 auto;
                overflow-y: auto;
            }
            
            .controls-panel {
                position: static;
                width: auto;
                margin-top: 12px;
            }
            
            .test-header {
                position: static;
                margin: 16px;
                padding: 24px;
            }
            
            .test-header h1 {
                font-size: 24px;
            }
        }
        
        /* Scrollbar Styling */
        .info-panel::-webkit-scrollbar,
        .controls-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .info-panel::-webkit-scrollbar-track,
        .controls-panel::-webkit-scrollbar-track {
            background: rgba(156, 163, 175, 0.1);
            border-radius: 3px;
        }
        
        .info-panel::-webkit-scrollbar-thumb,
        .controls-panel::-webkit-scrollbar-thumb {
            background: rgba(156, 163, 175, 0.3);
            border-radius: 3px;
        }
        
        .info-panel::-webkit-scrollbar-thumb:hover,
        .controls-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(156, 163, 175, 0.5);
        }

        /* Toast */
        #toast {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: rgba(31, 41, 55, 0.96);
            color: #fff;
            padding: 10px 14px;
            border-radius: 10px;
            font-size: 12px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            z-index: 9999;
        }
        #toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Tips floating panel */
        .tips-panel {
            position: fixed;
            top: 32px; /* align with bottom panels padding */
            left: 32px; /* upper-left corner */
            background: rgba(31, 41, 55, 0.85);
            color: #e5e7eb;
            padding: 16px 16px;
            border-radius: 16px;
            width: auto;
            z-index: 110;
            border: 1px solid rgba(75, 85, 99, 0.4);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(12px);
        }
        .tips-panel h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 700;
            color: #f9fafb;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(107, 114, 128, 0.3);
            padding-bottom: 6px;
            cursor: pointer;
        }
        .tips-panel .panel-content { font-size: 12px; line-height: 1.5; }
        .tips-panel ul { margin: 6px 0 0 16px; }
        .tips-panel li { margin: 4px 0; }
        .tips-panel.minimized { padding: 10px 12px; }

        @media (max-width: 768px) {
            .tips-panel {
                top: 16px;
                left: 16px;
                right: auto;
                bottom: auto;
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="page_wrap">
        <!-- Floating Tips Panel -->
        <div class="tips-panel" id="tips-panel">
            <h3 onclick="togglePanel('tips-panel')">
                <span>💡 Usage Tips</span>
                <button class="minimize-btn" id="tips-btn">−</button>
            </h3>
            <div class="panel-content">
                <ul>
                    <li>Left mouse: Orbit</li>
                    <li>Right mouse: Pan</li>
                    <li>Scroll: Zoom</li>
                    <li>R: Reset camera</li>
                    <li>W: Toggle wireframe</li>
                    <li>H: Hide/show UI</li>
                </ul>
            </div>
        </div>
        
        <div class="info-panels">
            <div class="info-panel" id="model-status-panel">
                <h3 onclick="togglePanel('model-status-panel')">
                    <span>📊 Model Status</span>
                    <button class="minimize-btn" id="model-status-btn">−</button>
                </h3>
                <div class="panel-content" id="model-status">Ready to load models...</div>
            </div>
            
            <div class="info-panel" id="camera-panel">
                <h3 onclick="togglePanel('camera-panel')">
                    <span>📍 Camera Position</span>
                    <button class="minimize-btn" id="camera-btn">−</button>
                </h3>
                <div class="panel-content camera-info">
                    <div>Position: <span id="camera-position">--, --, --</span></div>
                    <div>Target: <span id="camera-target">--, --, --</span></div>
                    <div>Distance: <span id="camera-distance">--</span></div>
                    <div>Rotation: <span id="camera-rotation">--, --</span></div>
                </div>
            </div>

            <!-- Animation Helper Panel (Phase 2: Tasks 2.1 - 2.5) -->
            <div class="info-panel" id="animation-helper-panel">
                <h3 onclick="togglePanel('animation-helper-panel')">
                    <span>🎬 Animation Helper</span>
                    <button class="minimize-btn" id="animation-helper-btn">−</button>
                </h3>
                <div class="panel-content">
                    <div class="kf-buttons">
                        <button class="btn primary" id="kf-add">➕ Add Keyframe</button>
                        <button class="btn secondary" id="kf-clear" title="Clear all keyframes">♻️ Clear</button>
                        <button class="btn neutral" id="kf-reset-view" title="Go to first keyframe" disabled>⏮️ First</button>
                    </div>
                    <div>
                        <strong style="font-size:12px;">Keyframes</strong>
                        <ul class="keyframe-list" id="kf-list">
                            <li class="empty-state" id="kf-empty">No keyframes set yet</li>
                        </ul>
                    </div>
                    <div>
                        <label style="display:block;font-size:11px;margin:6px 0 4px;opacity:.8;">Easing</label>
                        <select id="kf-ease">
                            <option value="linear">Linear</option>
                            <option value="easeIn">Ease In</option>
                            <option value="easeOut">Ease Out</option>
                            <option value="easeInOut">Ease InOut</option>
                            <option value="bounce">Bounce</option>
                        </select>
                    </div>
                    <div class="scrubber-row">
                        <span style="font-size:10px;opacity:.7;">Scrub</span>
                        <input type="range" id="kf-scrub" min="0" max="1" step="0.0001" value="0" />
                    </div>
                    <div class="playback-row">
                        <div class="playback-controls">
                            <button class="btn success" id="kf-play" disabled>▶️</button>
                            <button class="btn neutral" id="kf-pause" disabled>⏸️</button>
                            <button class="btn danger" id="kf-stop" disabled>⏹️</button>
                        </div>
                        <div class="playback-progress">
                            <progress id="kf-progress" value="0" max="1"></progress>
                            <span id="kf-time" style="font-size:10px;opacity:.7;width:55px;text-align:right;">0.0s</span>
                        </div>
                    </div>
                    <div class="library-row">
                        <input id="anim-name" placeholder="Animation name" />
                        <button class="btn primary" id="anim-save" title="Save current animation" disabled>💾</button>
                    </div>
                    <div class="saved-animations">
                        <label style="display:block;font-size:11px;margin:6px 0 4px;opacity:.8;">Saved Animations</label>
                        <select id="anim-list"><option value="">(none)</option></select>
                        <div class="library-actions">
                            <button class="btn neutral" id="anim-load" disabled>📂 Load</button>
                            <button class="btn neutral" id="anim-rename" disabled>✏️ Rename</button>
                            <button class="btn danger" id="anim-delete" disabled>🗑️ Delete</button>
                            <button class="btn secondary" id="anim-refresh">🔄 Refresh</button>
                        </div>
                    </div>
                    <div class="status-line" id="kf-status">Add 2+ keyframes to enable playback.</div>
                </div>
            </div>
            
            <div class="info-panel" id="performance-panel">
                <h3 onclick="togglePanel('performance-panel')">
                    <span>⚡ Performance</span>
                    <button class="minimize-btn" id="performance-btn">−</button>
                </h3>
                <div class="panel-content performance-info">
                    <div>FPS: <span id="fps-counter">--</span></div>
                    <div>Triangles: <span id="triangle-count">--</span></div>
                    <div>Draw Calls: <span id="draw-calls">--</span></div>
                    <div>Memory: <span id="memory-usage">--</span></div>
                </div>
            </div>

        <!-- Toast container -->
        <div id="toast"></div>

        <div class="controls-panel" id="controls-panel">
            <h3 onclick="togglePanel('controls-panel')">
                <span>Model Controls</span>
                <span class="header-actions">
                    <div class="refresh-icon" onclick="event.stopPropagation(); discoverModels();" title="Refresh Models">🔄</div>
                    <button class="minimize-btn" id="controls-btn" onclick="event.stopPropagation(); togglePanel('controls-panel');">−</button>
                </span>
            </h3>
            <div class="panel-content" id="controls-content">
                
                <!-- Mode Toggle -->
                <div class="mode-toggle">
                    <div style="font-size: 11px; margin-bottom: 5px;">Testing Mode:</div>
                    <div class="toggle-switch">
                        <div class="toggle-option active" onclick="setMode('single')" id="single-mode-btn">🎯 Single Model</div>
                        <div class="toggle-option" onclick="setMode('comparison')" id="comparison-mode-btn">🔄 Comparison</div>
                    </div>
                </div>
                
                <!-- Comparison Mode Panel -->
                <div class="comparison-panel" id="comparison-panel">
                    <div class="model-selector">
                        <label>Model A (Red):</label>
                        <select id="model-a-select">
                            <!-- Options will be dynamically populated -->
                        </select>
                    </div>
                    
                    <div class="model-selector">
                        <label>Model B (Blue):</label>
                        <select id="model-b-select">
                            <!-- Options will be dynamically populated -->
                        </select>
                    </div>
                    
                    <div class="opacity-slider">
                        <div style="font-size: 11px; margin-bottom: 5px;">Quality Comparison:</div>
                        <div class="slider-container">
                            <span class="slider-label">Model A</span>
                            <input type="range" class="slider" id="opacity-slider" min="0" max="100" value="50" oninput="updateOpacity(this.value)">
                            <span class="slider-label">Model B</span>
                        </div>
                        <div style="text-align: center; font-size: 10px; color: #888; margin-top: 5px;">
                            Opacity: <span id="opacity-display">50%</span> A / <span id="opacity-display-b">50%</span> B
                        </div>
                    </div>
                    
                    <!-- Model Toggle -->
                    <div class="model-toggle" style="margin-bottom: 16px;">
                        <div style="font-size: 11px; margin-bottom: 5px;">Quick Toggle:</div>
                        <div class="toggle-switch">
                            <div class="toggle-option active" onclick="toggleToModel('A')" id="model-a-toggle">Model A</div>
                            <div class="toggle-option" onclick="toggleToModel('B')" id="model-b-toggle">Model B</div>
                        </div>
                    </div>
                    
                    <div class="comparison-controls">
                    </div>
                </div>
                
                <!-- Single Model Controls (Dynamically Generated) -->
                <div class="single-model-controls" id="single-model-controls">
                    <!-- Model buttons will be populated dynamically -->
                </div>
                
                <hr style="margin: 16px 0; border-color: #333;">
                <div class="utility-controls">
                    <button class="btn neutral" onclick="resetCamera()">📷 Reset Camera</button>
                    <button class="btn neutral" onclick="toggleWireframe()">🔧 Toggle Wireframe</button>
                    <button class="btn neutral" onclick="copyCurrentPosition()">📋 Copy Camera Position</button>
                    <button class="btn neutral" onclick="showFullDebugInfo()">🐛 Full Debug Info</button>
                </div>
            </div>
        </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        let scene, camera, renderer, controls, currentModel;
        let loadingStartTime = 0;
        let performanceMonitor = {
            frameCount: 0,
            lastTime: 0,
            fps: 0
        };
        
        // =============================
        // 🎬 Animation Helper (Phase 2 & 3): Includes Tasks 2.1 - 2.5 & 3.1 - 3.5
        // =============================
        const animationHelper = {
            keyframes: [], // { id, position: Vector3, target: Vector3, timestamp }
            durations: [], // ms per segment (between i and i+1)
            easing: 'linear',
            playing: false,
            paused: false,
            startTime: 0,
            elapsedBeforePause: 0,
            rafId: null
        };

        const EASING = {
            linear: t => t,
            easeIn: t => t * t,
            easeOut: t => 1 - (1 - t) * (1 - t),
            easeInOut: t => t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t),
            bounce: t => {
                if (t < 1/2.75) return 7.5625 * t * t;
                if (t < 2/2.75) return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
                if (t < 2.5/2.75) return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
                return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
            }
        };
        
        // Comparison mode variables
        let isComparisonMode = false;
        let modelA = null;
        let modelB = null;
        let currentOpacity = 50;
        
        // Dynamic model discovery
        let MODEL_URLS = {};
        let availableModels = [];
        
        // ========================================
        // 📝 AUTOMATIC MODEL DETECTION:
        // The interface will automatically detect ALL .glb and .gltf files
        // in your public folder and display them with their exact filenames.
        // No need to list them here - just drop files into public/ folder!
        // ========================================
        const USER_MODELS = [
            // Optional: Add specific filenames here if auto-detection fails
        ];
        
        // Keep track of preferred model for auto-loading
        // Per request: always auto-load the smallest model first.
        let smallestModelKey = null;

        // Heuristic size ranking based on filename
        function sizeRankForName(name) {
            const n = (name || '').toLowerCase();
            if (n.includes('webp15')) return 1; // smallest
            if (n.includes('webp25')) return 2;
            if (n.includes('webp')) return 3;
            if (n.includes('with-textures') || n.includes('textures')) return 5; // likely largest
            return 4; // default in between
        }
        
        // Auto-discover models in public folder
        async function discoverModels() {
            try {
                updateModelStatus('✨ Loading available models...');
                
                // Direct list of your 4 models in the public folder
                const modelFiles = [
                    './public/Goetheviertel_250812_with-textures.glb',
                    './public/Goetheviertel_250812_with-textures_webp.glb',
                    './public/Goetheviertel_250812_with-textures_webp15.glb',
                    './public/Goetheviertel_250812_with-textures_webp25.glb'
                ];
                
                console.log('✅ Loading models:', modelFiles);
                
                // No need for separate GitHub models - using direct paths above
                
                // Create model entries
                availableModels = [];
                MODEL_URLS = {};
                
                // Add local files (preserve exact original filenames)
                modelFiles.forEach(filePath => {
                    const fileName = filePath.split('/').pop();
                    const displayName = fileName; // Use exact original filename as display name
                    
                    // Create unique key from filename but keep original name for display
                    const key = fileName.replace(/\.(gltf|glb)$/i, '').toLowerCase().replace(/[^a-z0-9]/g, '_');
                    
                    // Smart ordering based on file modification time or filename numbers
                    let priority = 0;
                    const numbers = fileName.match(/\d+/g);
                    if (numbers) {
                        // Use last number in filename as priority (higher = newer)
                        priority = parseInt(numbers[numbers.length - 1]) || 0;
                    }
                    
                    // Special handling for webp quality files (webp15, webp25, etc.)
                    const webpMatch = fileName.match(/webp(\d+)/i);
                    if (webpMatch) {
                        priority = parseInt(webpMatch[1]) + 1000; // Give webp files higher priority
                    }
                    
                    // Special handling for date-based naming
                    const dateMatch = fileName.match(/(\d{6})/); // YYMMDD format
                    if (dateMatch) {
                        priority = parseInt(dateMatch[1]) + 10000; // Date-based files get highest priority
                    }
                    
                    const modelInfo = {
                        key: key,
                        name: displayName, // Original filename without any modification
                        url: filePath,
                        type: filePath.endsWith('.glb') ? 'GLB' : 'GLTF',
                        source: 'Local',
                        priority: priority,
                        originalFileName: fileName
                    };
                    
                    availableModels.push(modelInfo);
                    MODEL_URLS[key] = filePath;
                });
                
                // Determine the smallest model by heuristic
                const localModels = availableModels.filter(m => m.source === 'Local');
                if (localModels.length > 0) {
                    const smallestLocal = localModels.reduce((smallest, current) => {
                        const sRank = sizeRankForName(smallest.name);
                        const cRank = sizeRankForName(current.name);
                        if (cRank < sRank) return current;
                        if (cRank === sRank) {
                            // tie-breaker: prefer GLB over GLTF for speed, then by filename lexicographically
                            const sType = smallest.type === 'GLB' ? 0 : 1;
                            const cType = current.type === 'GLB' ? 0 : 1;
                            if (cType < sType) return current;
                            if (cType === sType && (current.name < smallest.name)) return current;
                        }
                        return smallest;
                    });
                    smallestModelKey = smallestLocal.key;
                    console.log('🎯 Smallest local model detected:', smallestLocal.name, 'sizeRank:', sizeRankForName(smallestLocal.name));
                }
                
                // Sort models by priority (newest first)
                availableModels.sort((a, b) => (b.priority || 0) - (a.priority || 0));
                
                // Update UI
                populateModelSelectors();
                
                const modelCount = availableModels.length;
                
                updateModelStatus(`✅ Found ${modelCount} models! 🎮 Ready to test.`);
                
                // Auto-load the smallest model if available
                if (smallestModelKey && availableModels.find(m => m.key === smallestModelKey)) {
                    const smallestModel = availableModels.find(m => m.key === smallestModelKey);
                    updateModelStatus(`🚀 Auto-loading smallest model: ${smallestModel.name}...`);
                    setTimeout(() => {
                        loadModel(smallestModelKey, smallestModel.name);
                    }, 1500);
                }
                
                console.log('Discovered models:', availableModels);
                
            } catch (error) {
                console.warn('Could not auto-discover models:', error);
                // Fallback to hardcoded models
                await loadFallbackModels();
            }
        }
        
        // Fallback to hardcoded models if discovery fails
        async function loadFallbackModels() {
            availableModels = [
                { key: 'goetheviertel_textures', name: 'Goetheviertel With Textures', url: '/Goetheviertel_250812_with-textures.glb', type: 'GLB', source: 'Local' },
                { key: 'goetheviertel_webp', name: 'Goetheviertel WebP', url: '/Goetheviertel_250812_with-textures_webp.glb', type: 'GLB', source: 'Local' },
                { key: 'goetheviertel_webp15', name: 'Goetheviertel WebP15', url: '/Goetheviertel_250812_with-textures_webp15.glb', type: 'GLB', source: 'Local' },
                { key: 'goetheviertel_webp25', name: 'Goetheviertel WebP25', url: '/Goetheviertel_250812_with-textures_webp25.glb', type: 'GLB', source: 'Local' }
            ];
            
            MODEL_URLS = {};
            availableModels.forEach(model => {
                MODEL_URLS[model.key] = model.url;
            });
            
            populateModelSelectors();
            updateModelStatus('✅ Loaded fallback model list.<br/>🎮 Ready for testing!');

            // Auto-load the smallest model in fallback as well
            const smallest = availableModels.reduce((s, c) => {
                const sRank = sizeRankForName(s.name);
                const cRank = sizeRankForName(c.name);
                return (cRank < sRank) ? c : s;
            }, availableModels[0]);
            smallestModelKey = smallest.key;
            updateModelStatus(`🚀 Auto-loading smallest model: ${smallest.name}...`);
            setTimeout(() => {
                loadModel(smallestModelKey, smallest.name);
            }, 1200);
        }
        
        // Populate model selector dropdowns with separated groups
        function populateModelSelectors() {
            const selectA = document.getElementById('model-a-select');
            const selectB = document.getElementById('model-b-select');
            
            // Clear existing options
            selectA.innerHTML = '';
            selectB.innerHTML = '';
            
            // Separate models by source
            const localModels = availableModels.filter(m => m.source === 'Local');
            const githubModels = availableModels.filter(m => m.source === 'GitHub');
            
            // Helper function to add model group
            function addModelGroup(select, models, groupName) {
                if (models.length === 0) return;
                
                // Add group label
                const optgroup = document.createElement('optgroup');
                optgroup.label = groupName;
                
                models.forEach(model => {
                    const iconMap = {
                        'GLTF': '📄',
                        'GLB': '📦'
                    };
                    
                    const icon = iconMap[model.type] || '📄';
                    const displayText = `${icon} ${model.name}`;
                    
                    const option = document.createElement('option');
                    option.value = model.key;
                    option.textContent = displayText;
                    optgroup.appendChild(option);
                });
                
                select.appendChild(optgroup);
            }
            
            // Add groups to both selectors
            addModelGroup(selectA, localModels, '🏠 Local Models');
            addModelGroup(selectA, githubModels, '🌐 GitHub Models');
            
            addModelGroup(selectB, localModels, '🏠 Local Models');
            addModelGroup(selectB, githubModels, '🌐 GitHub Models');
            
            // Set default selections if models exist
            if (availableModels.length >= 2) {
                selectA.value = availableModels[0].key;
                selectB.value = availableModels[1].key;
            }
            
            // Add auto-loading event listeners for comparison mode
            selectA.addEventListener('change', () => {
                if (isComparisonMode) {
                    loadBothModels();
                }
            });
            
            selectB.addEventListener('change', () => {
                if (isComparisonMode) {
                    loadBothModels();
                }
            });
            
            // Update single model controls
            updateSingleModelControls();
        }
        
        // Update single model control buttons with two-column layout
        function updateSingleModelControls() {
            const container = document.getElementById('single-model-controls');
            container.innerHTML = '';
            
            // Separate models by source
            const localModels = availableModels.filter(m => m.source === 'Local');
            const githubModels = availableModels.filter(m => m.source === 'GitHub');
            
            // Create grid container
            const gridContainer = document.createElement('div');
            gridContainer.className = 'models-grid';
            
            // Helper function to create model group
            function createModelGroup(models, groupName) {
                const group = document.createElement('div');
                group.className = 'model-group';
                
                if (models.length === 0) return group;
                
                // Add group header
                const groupHeader = document.createElement('div');
                groupHeader.className = 'model-group-label';
                groupHeader.textContent = groupName;
                group.appendChild(groupHeader);
                
                // Add buttons for models
                models.forEach(model => {
                    const button = document.createElement('button');
                    button.className = 'btn';
                    button.onclick = () => loadModel(model.key, model.name);
                    
                    const iconMap = {
                        'GLTF': '📄',
                        'GLB': '📦'
                    };
                    
                    const icon = iconMap[model.type] || '📄';
                    // Use original filename without truncation for better readability
                    button.innerHTML = `${icon} ${model.name}`;
                    button.title = model.name; // Add tooltip for full name
                    group.appendChild(button);
                });
                
                return group;
            }
            
            // Create both groups
            const localGroup = createModelGroup(localModels, '🏠 Local Models');
            const githubGroup = createModelGroup(githubModels, '🌐 GitHub Models');
            
            // Add groups to grid
            gridContainer.appendChild(localGroup);
            gridContainer.appendChild(githubGroup);
            
            container.appendChild(gridContainer);
        }

        function updateModelStatus(msg, isError = false) {
            const statusEl = document.getElementById('model-status');
            // Reset to default color (no classes)
            statusEl.classList.remove('status-success', 'status-error', 'status-loading');
            statusEl.style.color = '';

            // Only success (first line) should be green
            if (msg && msg.includes('✅')) {
                const parts = String(msg).split('<br/>');
                const first = parts.shift();
                const rebuilt = [`<span class="status-success">${first}</span>`, ...parts].join('<br/>');
                statusEl.innerHTML = rebuilt;
            } else {
                statusEl.innerHTML = msg;
            }

            console.log(String(msg).replace(/<br\/>/g, '\n').replace(/<[^>]*>/g, ''));
        }
        
        // Mode switching functions
        function setMode(mode) {
            isComparisonMode = (mode === 'comparison');
            
            // Update UI
            document.getElementById('single-mode-btn').classList.toggle('active', !isComparisonMode);
            document.getElementById('comparison-mode-btn').classList.toggle('active', isComparisonMode);
            document.getElementById('comparison-panel').style.display = isComparisonMode ? 'block' : 'none';
            document.getElementById('single-model-controls').style.display = isComparisonMode ? 'none' : 'block';
            
            // Clear existing models when switching modes
            clearAllModels();
            
            if (isComparisonMode) {
                updateModelStatus('🔄 Comparison mode activated!<br/>Select two models to compare quality differences.');
            } else {
                updateModelStatus('🎯 Single model mode activated!<br/>Click a button to load a model.');
            }
        }
        
        function clearAllModels() {
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            if (modelA) {
                scene.remove(modelA);
                modelA = null;
            }
            if (modelB) {
                scene.remove(modelB);
                modelB = null;
            }
        }
        
        // Dual model loading function
        async function loadBothModels() {
            const modelAKey = document.getElementById('model-a-select').value;
            const modelBKey = document.getElementById('model-b-select').value;
            
            if (modelAKey === modelBKey) {
                updateModelStatus('⚠️ Please select different models for comparison!', true);
                return;
            }
            
            updateModelStatus('🔄 Loading both models for comparison...');
            clearAllModels();
            
            try {
                // Load both models in parallel
                const [modelAResult, modelBResult] = await Promise.all([
                    loadModelForComparison(modelAKey, 'Model A'),
                    loadModelForComparison(modelBKey, 'Model B')
                ]);
                
                modelA = modelAResult.model;
                modelB = modelBResult.model;
                
                // Position and scale models identically
                setupDualModels();
                
                // Apply initial opacity
                updateOpacity(currentOpacity);
                
                updateModelStatus(`
                    ✅ Comparison loaded successfully!<br/>
                    📦 Model A: ${modelAResult.meshCount} meshes | ${modelAResult.loadTime}s<br/>
                    📦 Model B: ${modelBResult.meshCount} meshes | ${modelBResult.loadTime}s<br/>
                    🎛️ Use the slider to compare quality differences!
                `);
                
            } catch (error) {
                console.error('Dual model loading error:', error);
                updateModelStatus(`❌ Failed to load models for comparison:<br/>${error.message}`, true);
            }
        }
        
        // Load single model for comparison
        function loadModelForComparison(modelKey, displayName) {
            return new Promise((resolve, reject) => {
                const url = MODEL_URLS[modelKey];
                if (!url) {
                    reject(new Error(`Unknown model: ${modelKey}`));
                    return;
                }
                
                const loader = new GLTFLoader();
                const dracoLoader = new DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                dracoLoader.preload();
                loader.setDRACOLoader(dracoLoader);
                
                const startTime = performance.now();
                
                loader.load(
                    url,
                    (gltf) => {
                        const loadTime = ((performance.now() - startTime) / 1000).toFixed(2);
                        const model = gltf.scene;
                        
                        // Count meshes
                        let meshCount = 0;
                        model.traverse((child) => {
                            if (child.isMesh) {
                                meshCount++;
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                if (child.material) {
                                    child.material.needsUpdate = true;
                                    if (child.material.map && renderer.capabilities) {
                                        child.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
                                    }
                                }
                            }
                        });
                        
                        resolve({ model, meshCount, loadTime });
                    },
                    undefined,
                    (error) => reject(error)
                );
            });
        }
        
        // Setup dual models with identical positioning
        function setupDualModels() {
            if (!modelA || !modelB) return;
            
            // Calculate combined bounding box for consistent scaling
            const boxA = new THREE.Box3().setFromObject(modelA);
            const boxB = new THREE.Box3().setFromObject(modelB);
            
            const sizeA = boxA.getSize(new THREE.Vector3());
            const sizeB = boxB.getSize(new THREE.Vector3());
            
            // Use the larger model as reference for scaling
            const maxSizeA = Math.max(sizeA.x, sizeA.y, sizeA.z);
            const maxSizeB = Math.max(sizeB.x, sizeB.y, sizeB.z);
            const referenceSize = Math.max(maxSizeA, maxSizeB);
            const scale = 100 / referenceSize;
            
            // Scale both models identically
            modelA.scale.setScalar(scale);
            modelB.scale.setScalar(scale);
            
            // Center both models at the same position
            const centerA = boxA.getCenter(new THREE.Vector3());
            const centerB = boxB.getCenter(new THREE.Vector3());
            
            modelA.position.set(-centerA.x * scale, -centerA.y * scale, -centerA.z * scale);
            modelB.position.set(-centerB.x * scale, -centerB.y * scale, -centerB.z * scale);
            
            // Add both models to scene
            scene.add(modelA);
            scene.add(modelB);
            
            // Position camera for good view
            const idealDistance = referenceSize * scale * 1.5;
            camera.position.set(idealDistance * 0.5, idealDistance * 0.3, idealDistance);
            camera.lookAt(0, 0, 0);
            controls.update();
        }
        
        // Opacity control functions
        function updateOpacity(value) {
            currentOpacity = parseInt(value);
            const opacityA = (100 - currentOpacity) / 100;
            const opacityB = currentOpacity / 100;
            
            // Update display
            document.getElementById('opacity-display').textContent = `${Math.round(opacityA * 100)}%`;
            document.getElementById('opacity-display-b').textContent = `${Math.round(opacityB * 100)}%`;
            
            // Apply opacity to models
            if (modelA) {
                modelA.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.transparent = true;
                        child.material.opacity = opacityA;
                        child.material.needsUpdate = true;
                    }
                });
            }
            
            if (modelB) {
                modelB.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.transparent = true;
                        child.material.opacity = opacityB;
                        child.material.needsUpdate = true;
                    }
                });
            }
        }
        
        // Swap models A and B
        function swapModels() {
            const selectA = document.getElementById('model-a-select');
            const selectB = document.getElementById('model-b-select');
            
            const tempValue = selectA.value;
            selectA.value = selectB.value;
            selectB.value = tempValue;
            
            updateModelStatus('🔄 Models swapped! Click "Load Both" to apply changes.');
        }
        
        // Load preset comparison pairs
        function loadPreset(presetName) {
            const selectA = document.getElementById('model-a-select');
            const selectB = document.getElementById('model-b-select');
            
            switch (presetName) {
                case 'texture-comparison':
                    // Find best available models for texture comparison
                    if (availableModels.find(m => m.key === 'goetheviertel_textures') && 
                        availableModels.find(m => m.key === 'goetheviertel_webp')) {
                        selectA.value = 'goetheviertel_textures';
                        selectB.value = 'goetheviertel_webp';
                        updateModelStatus('🎨 Texture comparison preset loaded!<br/>Full Textures vs WebP Compressed');
                    } else {
                        updateModelStatus('⚠️ Texture comparison models not available', true);
                    }
                    break;
                case 'format-comparison':
                    // Compare WebP compression levels
                    if (availableModels.find(m => m.key === 'goetheviertel_webp15') && 
                        availableModels.find(m => m.key === 'goetheviertel_webp25')) {
                        selectA.value = 'goetheviertel_webp15';
                        selectB.value = 'goetheviertel_webp25';
                        updateModelStatus('🖼️ WebP comparison preset loaded!<br/>15% vs 25% Quality');
                    } else {
                        updateModelStatus('⚠️ WebP comparison models not available', true);
                    }
                    break;
                default:
                    updateModelStatus('⚠️ Unknown preset: ' + presetName, true);
            }
        }
        
        function updateCameraInfo() {
            if (!camera || !controls) return;
            
            const pos = camera.position;
            const target = controls.target;
            const distance = pos.distanceTo(target);
            
            // Calculate rotation in degrees
            const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
            const rotX = THREE.MathUtils.radToDeg(euler.x);
            const rotY = THREE.MathUtils.radToDeg(euler.y);
            
            document.getElementById('camera-position').textContent = 
                `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
            document.getElementById('camera-target').textContent = 
                `${target.x.toFixed(1)}, ${target.y.toFixed(1)}, ${target.z.toFixed(1)}`;
            document.getElementById('camera-distance').textContent = distance.toFixed(1);
            document.getElementById('camera-rotation').textContent = 
                `${rotX.toFixed(1)}°, ${rotY.toFixed(1)}°`;
        }
        
        function updatePerformanceInfo() {
            if (!renderer) return;
            
            // Calculate FPS
            performanceMonitor.frameCount++;
            const currentTime = performance.now();
            if (currentTime - performanceMonitor.lastTime >= 1000) {
                performanceMonitor.fps = Math.round(performanceMonitor.frameCount * 1000 / (currentTime - performanceMonitor.lastTime));
                performanceMonitor.frameCount = 0;
                performanceMonitor.lastTime = currentTime;
            }
            
            const info = renderer.info;
            document.getElementById('fps-counter').textContent = performanceMonitor.fps;
            document.getElementById('triangle-count').textContent = info.render.triangles.toLocaleString();
            document.getElementById('draw-calls').textContent = info.render.calls;
            document.getElementById('memory-usage').textContent = 
                `${info.memory.geometries}G / ${info.memory.textures}T`;
        }
        
        function loadModel(type, displayName) {
            const url = MODEL_URLS[type];
            if (!url) {
                updateModelStatus(`❌ Unknown model type: ${type}`, true);
                return;
            }
            
            loadingStartTime = performance.now();
            updateModelStatus(`🔄 Loading ${displayName}...<br/>⏱️ Started at ${new Date().toLocaleTimeString()}`);
            
            // Remove existing model
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            
            const loader = new GLTFLoader();
            
            // Set up DRACO loader
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
            dracoLoader.preload();
            loader.setDRACOLoader(dracoLoader);
            
            let lastProgressTime = loadingStartTime;
            
            loader.load(
                url,
                (gltf) => {
                    const loadTime = performance.now() - loadingStartTime;
                    
                    currentModel = gltf.scene;
                    
                    // Scale and center the model
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const size = box.getSize(new THREE.Vector3());
                    const maxSize = Math.max(size.x, size.y, size.z);
                    const scale = 100 / maxSize;
                    currentModel.scale.setScalar(scale);
                    
                    const center = box.getCenter(new THREE.Vector3());
                    currentModel.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
                    
                    // Count meshes and materials
                    let meshCount = 0;
                    let materialCount = 0;
                    let textureCount = 0;
                    const materials = new Set();
                    
                    currentModel.traverse((child) => {
                        if (child.isMesh) {
                            meshCount++;
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            if (child.material) {
                                materials.add(child.material.uuid);
                                if (child.material.map) textureCount++;
                                if (child.material.normalMap) textureCount++;
                                if (child.material.roughnessMap) textureCount++;
                                if (child.material.metalnessMap) textureCount++;
                                
                                child.material.needsUpdate = true;
                                if (child.material.map && renderer.capabilities) {
                                    child.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
                                }
                            }
                        }
                    });
                    
                    materialCount = materials.size;
                    scene.add(currentModel);
                    
                    // Preserve current camera; only update info
                    controls.update();
                    const currentDistance = camera.position.distanceTo(controls.target);
                    
                    // Calculate file size estimate
                    const fileSize = gltf.parser ? 
                        (gltf.parser.json.buffers ? 
                            gltf.parser.json.buffers.reduce((sum, buf) => sum + (buf.byteLength || 0), 0) : 0) : 0;
                    
                    updateModelStatus(`
                        ✅ ${displayName} loaded successfully!<br/>
                        ⏱️ <strong>Load time: ${(loadTime / 1000).toFixed(2)}s</strong><br/>
                        📦 Meshes: ${meshCount} | Materials: ${materialCount}<br/>
                        🎨 Textures: ${textureCount} | Scale: ${scale.toFixed(2)}x<br/>
                        📏 Size: ${size.x.toFixed(0)} × ${size.y.toFixed(0)} × ${size.z.toFixed(0)}<br/>
                        💾 Est. size: ${(fileSize / 1024 / 1024).toFixed(1)}MB<br/>
                        📍 Camera distance ${currentDistance.toFixed(1)} (preserved)
                    `);
                    
                    window.map3dScene = { scene, camera, renderer, controls, model: currentModel };
                },
                (progress) => {
                    const now = performance.now();
                    const currentLoadTime = (now - loadingStartTime) / 1000;
                    
                    if (progress.total > 0) {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        const loaded = (progress.loaded / 1024 / 1024).toFixed(1);
                        const total = (progress.total / 1024 / 1024).toFixed(1);
                        const speed = (progress.loaded / 1024 / (now - loadingStartTime)) * 1000; // KB/s
                        
                        updateModelStatus(`
                            📥 Loading ${displayName}: ${percent}%<br/>
                            📊 ${loaded}MB / ${total}MB<br/>
                            🚀 Speed: ${speed.toFixed(0)} KB/s<br/>
                            ⏱️ Elapsed: ${currentLoadTime.toFixed(1)}s
                        `);
                    } else {
                        updateModelStatus(`
                            📥 Loading ${displayName}...<br/>
                            📊 ${(progress.loaded / 1024 / 1024).toFixed(1)}MB loaded<br/>
                            ⏱️ Elapsed: ${currentLoadTime.toFixed(1)}s
                        `);
                    }
                },
                (error) => {
                    const failTime = (performance.now() - loadingStartTime) / 1000;
                    console.error(`${displayName} loading error:`, error);
                    updateModelStatus(`
                        ❌ Failed to load ${displayName}<br/>
                        💥 Error: ${error.message}<br/>
                        ⏱️ Failed after: ${failTime.toFixed(1)}s<br/>
                        🌐 URL: ${url.substring(0, 50)}...
                    `, true);
                }
            );
        }
        
        function initMap() {
            try {
                updateModelStatus('🚀 Initializing 3D environment...');
                
                // Create container
                const container = document.createElement('div');
                container.id = 'map-3d-container';
                container.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    z-index: 0; /* Raised so it can receive pointer events outside panels */
                    background: #000000;
                `;
                document.body.insertBefore(container, document.body.firstChild);
                
                // Create scene
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x87CEEB, 50, 1000);
                
                // Create camera
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
                camera.position.set(-23.8, 69.2, 89.3);
                
                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);
                
                // Add controls
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 20;
                controls.maxDistance = 800;
                controls.maxPolarAngle = Math.PI / 2.1;
                // Set default camera target
                controls.target.set(3.5, -35.4, -14.7);
                camera.lookAt(3.5, -35.4, -14.7);
                // Persist as reset state
                if (typeof controls.saveState === 'function') controls.saveState();
                
                // Add lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(200, 200, 100);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.4);
                fillLight.position.set(-100, 50, -100);
                scene.add(fillLight);
                
                // Animation loop with monitoring
                function animate() {
                    requestAnimationFrame(animate);
                    
                    if (controls) controls.update();
                    if (renderer && scene && camera) renderer.render(scene, camera);
                    
                    // Update info displays
                    updateCameraInfo();
                    updatePerformanceInfo();
                }
                animate();
                
                // Handle resize
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Detect user interaction to optionally stop animation playback (robust debounce)
                let interactionTimeout = null;
                animationHelper.suppressNextInteraction = false; // ignore Play click during activation
                const canvasEl = renderer.domElement;
                let pointerActive = false; // true only while user is physically dragging
                let lastInteractionAt = 0;  // timestamp of last genuine interaction
                const markInteracting = (source) => {
                    if (animationHelper.suppressNextInteraction) return; // ignore suppressed events
                    animationHelper._userInteracting = true;
                    lastInteractionAt = performance.now();
                    if (interactionTimeout) clearTimeout(interactionTimeout);
                    interactionTimeout = setTimeout(() => { animationHelper._userInteracting = false; }, 650); // idle threshold
                };
                const pointerDownHandler = (e) => {
                    if (canvasEl.contains(e.target) || e.target === canvasEl) {
                        pointerActive = true;
                        markInteracting('pointerdown');
                    }
                };
                const pointerUpHandler = () => { pointerActive = false; };
                window.addEventListener('pointerdown', pointerDownHandler, { passive: true });
                window.addEventListener('pointerup', pointerUpHandler, { passive: true });
                window.addEventListener('pointercancel', pointerUpHandler, { passive: true });
                window.addEventListener('wheel', (e) => {
                    if (canvasEl.contains(e.target) || e.target === canvasEl) markInteracting('wheel');
                }, { passive: true });
                window.addEventListener('pointermove', (e) => {
                    if (!pointerActive) return;
                    if (canvasEl.contains(e.target) || e.target === canvasEl) markInteracting('pointermove');
                }, { passive: true });
                // Touch support
                window.addEventListener('touchstart', (e) => {
                    if ([...e.touches].some(t => true)) { // basic truthy; rely on target check of first touch
                        if (canvasEl.contains(e.target) || e.target === canvasEl) {
                            pointerActive = true;
                            markInteracting('touchstart');
                        }
                    }
                }, { passive: true });
                window.addEventListener('touchend', () => { pointerActive = false; }, { passive: true });
                window.addEventListener('touchcancel', () => { pointerActive = false; }, { passive: true });
                window.addEventListener('touchmove', (e) => {
                    if (!pointerActive) return;
                    if (canvasEl.contains(e.target) || e.target === canvasEl) markInteracting('touchmove');
                }, { passive: true });
                // Keyboard (restrict to camera-affecting keys)
                window.addEventListener('keydown', (e) => {
                    const tag = document.activeElement && document.activeElement.tagName;
                    if (tag && ['INPUT','TEXTAREA','SELECT'].includes(tag)) return;
                    if (['r','w'].includes(e.key.toLowerCase())) markInteracting('key');
                }, { passive: true });
                // OrbitControls change only counts while actively dragging (prevents inertia/damping from flagging)
                if (controls) {
                    controls.addEventListener('change', () => { if (pointerActive) markInteracting('controls'); });
                }
                // Expose for debugging if needed
                window._ahDebugInteraction = () => ({ pointerActive, lastInteractionAt, userInteracting: animationHelper._userInteracting });

                // Keyboard shortcuts for tips
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() === 'r') { window.resetCamera(); }
                    if (e.key.toLowerCase() === 'w') { window.toggleWireframe(); }
                    if (e.key.toLowerCase() === 'h') { document.body.classList.toggle('ui-hidden'); }
                });
                
                updateModelStatus('✅ 3D environment ready!<br/>🎮 Use controls to load and test models.');
                
                // Enable click-to-copy on camera info rows
                setupCameraCopyHandlers();
                
                // Set up minimize button click handlers
                setupMinimizeButtons();
                
                // Fix controls panel pointer events
                setTimeout(() => fixControlsPanel(), 100);
                
                // Debug: Check current UI mode states
                console.log('🐛 UI States after init:', {
                    uiHidden: document.body.classList.contains('ui-hidden'),
                    bodyClasses: Array.from(document.body.classList)
                });
                
            } catch (error) {
                console.error('Init error:', error);
                updateModelStatus(`❌ Initialization failed:<br/>${error.message}`, true);
            }
        }
        
        // Panel minimize/maximize functionality
        window.testControlsPanel = function() {
            console.log('🧪 Testing controls panel...');
            
            // Test if elements exist
            const singleBtn = document.getElementById('single-mode-btn');
            const comparisonBtn = document.getElementById('comparison-mode-btn');
            const modelSelect = document.getElementById('model-a-select');
            
            console.log('Elements found:', {
                singleBtn: !!singleBtn,
                comparisonBtn: !!comparisonBtn,
                modelSelect: !!modelSelect
            });
            
            if (singleBtn) {
                console.log('Single btn onclick:', singleBtn.onclick ? 'exists' : 'MISSING');
                console.log('Single btn getAttribute onclick:', singleBtn.getAttribute('onclick'));
            }
            
            // Try to programmatically trigger setMode
            if (window.setMode) {
                console.log('setMode function exists, testing...');
                try {
                    window.setMode('comparison');
                    console.log('✅ setMode(comparison) successful');
                } catch (e) {
                    console.error('❌ setMode failed:', e);
                }
            } else {
                console.error('❌ setMode function not found');
            }
        };

        window.debugPanelStates = function() {
            console.log('🐛 Panel Debug Info:');
            console.log('Body classes:', Array.from(document.body.classList));
            console.log('UI hidden mode:', document.body.classList.contains('ui-hidden'));
            
            const panels = [
                'model-status-panel',
                'camera-panel', 
                'animation-helper-panel',
                'performance-panel',
                'controls-panel'
            ];
            
            panels.forEach(id => {
                const panel = document.getElementById(id);
                if (panel) {
                    const computedStyle = window.getComputedStyle(panel);
                    console.log(`${id}:`, {
                        pointerEvents: computedStyle.pointerEvents,
                        display: computedStyle.display,
                        visibility: computedStyle.visibility
                    });
                }
            });
            
            // Test controls panel elements
            const selects = document.querySelectorAll('#controls-panel select');
            const buttons = document.querySelectorAll('#controls-panel button');
            console.log(`Controls panel: ${selects.length} selects, ${buttons.length} buttons`);
            selects.forEach((select, i) => {
                const style = window.getComputedStyle(select);
                console.log(`Select ${i}:`, {
                    pointerEvents: style.pointerEvents,
                    disabled: select.disabled
                });
            });
        };

        window.togglePanel = function(panelId) {
            const panel = document.getElementById(panelId);
            const content = panel.querySelector('.panel-content');
            const btn = panel.querySelector('.minimize-btn');
            
            if (content.classList.contains('minimized')) {
                // Expand
                content.classList.remove('minimized');
                panel.classList.remove('minimized');
                btn.textContent = '−';
                btn.title = 'Minimize panel';
            } else {
                // Minimize
                content.classList.add('minimized');
                panel.classList.add('minimized');
                btn.textContent = '+';
                btn.title = 'Expand panel';
            }
        };
        
        // Model toggle function for comparison mode
        window.toggleToModel = function(modelLetter) {
            if (!isComparisonMode) return;
            
            const toggleA = document.getElementById('model-a-toggle');
            const toggleB = document.getElementById('model-b-toggle');
            const selectA = document.getElementById('model-a-select');
            const selectB = document.getElementById('model-b-select');
            
            // Update toggle visual state
            toggleA.classList.toggle('active', modelLetter === 'A');
            toggleB.classList.toggle('active', modelLetter === 'B');
            
            // Save current camera position before clearing models
            const savedCameraPosition = camera.position.clone();
            const savedCameraTarget = controls.target.clone();
            
            // Clear existing models
            clearAllModels();
            
            if (modelLetter === 'A') {
                // Show only Model A
                const modelAKey = selectA.value;
                const modelAInfo = availableModels.find(m => m.key === modelAKey);
                if (modelAInfo) {
                    updateModelStatus(`🔄 Loading Model A: ${modelAInfo.name}...`);
                    loadModelForComparison(modelAKey, 'Model A').then(result => {
                        modelA = result.model;
                        modelB = null;
                        setupSingleModelWithCamera(modelA, savedCameraPosition, savedCameraTarget);
                        updateModelStatus(`✅ Model A loaded: ${modelAInfo.name}<br/>📦 ${result.meshCount} meshes | ${result.loadTime}s`);
                    }).catch(error => {
                        updateModelStatus(`❌ Failed to load Model A: ${error.message}`, true);
                    });
                }
            } else {
                // Show only Model B  
                const modelBKey = selectB.value;
                const modelBInfo = availableModels.find(m => m.key === modelBKey);
                if (modelBInfo) {
                    updateModelStatus(`🔄 Loading Model B: ${modelBInfo.name}...`);
                    loadModelForComparison(modelBKey, 'Model B').then(result => {
                        modelB = result.model;
                        modelA = null;
                        setupSingleModelWithCamera(modelB, savedCameraPosition, savedCameraTarget);
                        updateModelStatus(`✅ Model B loaded: ${modelBInfo.name}<br/>📦 ${result.meshCount} meshes | ${result.loadTime}s`);
                    }).catch(error => {
                        updateModelStatus(`❌ Failed to load Model B: ${error.message}`, true);
                    });
                }
            }
        };
        
        // Setup single model in comparison mode (preserves existing camera position)
        function setupSingleModel(model) {
            if (!model) return;
            
            // Calculate bounding box and scale
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxSize = Math.max(size.x, size.y, size.z);
            const scale = 100 / maxSize;
            
            // Scale and center the model
            model.scale.setScalar(scale);
            const center = box.getCenter(new THREE.Vector3());
            model.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
            
            // Add to scene
            scene.add(model);
            
            // Position camera for good view (only if camera hasn't been positioned yet)
            if (!camera.position.length()) {
                const idealDistance = maxSize * scale * 1.5;
                camera.position.set(idealDistance * 0.5, idealDistance * 0.3, idealDistance);
                camera.lookAt(0, 0, 0);
            }
            controls.update();
        }
        
        // Setup single model with saved camera position
        function setupSingleModelWithCamera(model, savedPosition, savedTarget) {
            if (!model) return;
            
            // Calculate bounding box and scale
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxSize = Math.max(size.x, size.y, size.z);
            const scale = 100 / maxSize;
            
            // Scale and center the model
            model.scale.setScalar(scale);
            const center = box.getCenter(new THREE.Vector3());
            model.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
            
            // Add to scene
            scene.add(model);
            
            // Restore saved camera position
            camera.position.copy(savedPosition);
            controls.target.copy(savedTarget);
            camera.lookAt(savedTarget);
            controls.update();
        }
        
        // Global functions
        window.loadModel = loadModel;
        window.setMode = setMode;
        window.loadBothModels = loadBothModels;
        window.updateOpacity = updateOpacity;
        window.swapModels = swapModels;
        window.loadPreset = loadPreset;
        
        window.resetCamera = function() {
            if (camera && controls) {
                camera.position.set(-23.8, 69.2, 89.3);
                controls.target.set(3.5, -35.4, -14.7);
                camera.lookAt(3.5, -35.4, -14.7);
                if (typeof controls.saveState === 'function') controls.saveState();
                controls.update();
                updateModelStatus('📷 Camera reset to default position');
            }
        };
        
        window.toggleWireframe = function() {
            if (currentModel) {
                let wireframe = false;
                currentModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.wireframe = !child.material.wireframe;
                        wireframe = child.material.wireframe;
                    }
                });
                updateModelStatus(`🔧 Wireframe mode: ${wireframe ? 'ON' : 'OFF'}`);
            }
        };
        
        // Reusable safe copy helper with fallback for non-secure contexts
        async function safeCopy(text) {
            console.log('[safeCopy] Attempting to copy:', text.slice(0, 50) + '...');
            
            // 1. Modern API (must be secure context: https or localhost)
            if (navigator.clipboard && window.isSecureContext) {
                try {
                    await navigator.clipboard.writeText(text);
                    console.log('[safeCopy] ✅ Clipboard API success');
                    return true;
                } catch (err) {
                    console.warn('[safeCopy] navigator.clipboard failed, falling back', err);
                }
            } else {
                console.log('[safeCopy] Clipboard API not available (secure context:', window.isSecureContext, 'clipboard:', !!navigator.clipboard, ')');
            }
            
            // 2. Old IE / Edge HTML clipboardData
            try {
                if (window.clipboardData && window.clipboardData.setData) {
                    const result = window.clipboardData.setData('Text', text);
                    console.log('[safeCopy] clipboardData result:', result);
                    return result;
                }
            } catch (err) { 
                console.warn('[safeCopy] clipboardData failed', err);
            }
            
            // 3. execCommand fallback (must occur during a user gesture to be reliable)
            try {
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.opacity = '0';
                ta.style.pointerEvents = 'none';
                document.body.appendChild(ta);
                ta.focus({ preventScroll: true });
                ta.select();
                ta.setSelectionRange(0, ta.value.length);
                const ok = document.execCommand('copy');
                document.body.removeChild(ta);
                console.log('[safeCopy] execCommand result:', ok);
                if (ok) return true;
            } catch (err) {
                console.warn('[safeCopy] execCommand fallback failed', err);
            }
            
            console.error('[safeCopy] ❌ All clipboard methods failed');
            return false;
        }

        window.copyCurrentPosition = async function() {
            if (!(camera && controls)) return;
            const pos = camera.position;
            const target = controls.target;
            const jsCode = `// Camera position for Webflow\n`+
`camera.position.set(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)});\n`+
`camera.lookAt(${target.x.toFixed(1)}, ${target.y.toFixed(1)}, ${target.z.toFixed(1)});\n`+
`controls.target.set(${target.x.toFixed(1)}, ${target.y.toFixed(1)}, ${target.z.toFixed(1)});`;
            const ok = await safeCopy(jsCode);
            if (ok) {
                updateModelStatus('📋 Camera position copied to clipboard!<br/>Ready to paste into your production code.');
                showToast('Camera code copied');
            } else {
                updateModelStatus('⚠️ Copy failed. Select & copy manually below:<br/><pre style="font-size:11px;white-space:pre-wrap;max-height:120px;overflow:auto;">'+jsCode.replace(/[<>]/g,m=>({'<':'&lt;','>':'&gt;'}[m]))+'</pre>');
                showToast('Copy failed');
            }
        };

        function showToast(message) {
            const toast = document.getElementById('toast');
            if (!toast) return;
            toast.textContent = message;
            toast.classList.add('show');
            clearTimeout(showToast._t);
            showToast._t = setTimeout(() => {
                toast.classList.remove('show');
            }, 1500);
        }

        function setupCameraCopyHandlers() {
            // Set up camera panel copyable rows
            const cameraRows = document.querySelectorAll('#camera-panel .camera-info div');
            cameraRows.forEach((row) => {
                row.style.cursor = 'pointer';
                row.title = 'Click to copy';
                row.classList.add('copyable');
                row.addEventListener('click', async () => {
                    const labelNode = row.childNodes[0];
                    const label = labelNode ? String(labelNode.textContent || '').replace(':','').trim() : 'Value';
                    const span = row.querySelector('span');
                    const value = span ? span.textContent.trim() : row.textContent.trim();
                    const text = `${label}: ${value}`;
                    const ok = await safeCopy(text);
                    showToast(ok ? `${label} copied` : 'Copy failed');
                });
            });
            
            // Set up model status panel as copyable
            const modelStatus = document.getElementById('model-status');
            if (modelStatus) {
                modelStatus.style.cursor = 'pointer';
                modelStatus.title = 'Click to copy model status';
                modelStatus.classList.add('copyable');
                modelStatus.addEventListener('click', async () => {
                    const text = modelStatus.textContent || modelStatus.innerText || '';
                    const ok = await safeCopy(text.trim());
                    showToast(ok ? 'Model status copied' : 'Copy failed');
                });
            }
        }
        
        function setupMinimizeButtons() {
            // Set up minimize button handlers for panels that don't have inline onclick
            const buttons = [
                { id: 'tips-btn', panelId: 'tips-panel' },
                { id: 'model-status-btn', panelId: 'model-status-panel' },
                { id: 'camera-btn', panelId: 'camera-panel' },
                { id: 'animation-helper-btn', panelId: 'animation-helper-panel' },
                { id: 'performance-btn', panelId: 'performance-panel' }
            ];
            
            buttons.forEach(({ id, panelId }) => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        togglePanel(panelId);
                    };
                }
            });
        }

        function fixControlsPanel() {
            console.log('🔧 Fixing controls panel...');
            
            // Get the controls panel and log its state
            const controlsPanel = document.getElementById('controls-panel');
            if (!controlsPanel) {
                console.error('❌ Controls panel not found!');
                return;
            }
            
            const style = window.getComputedStyle(controlsPanel);
            console.log('Controls panel computed styles:', {
                pointerEvents: style.pointerEvents,
                zIndex: style.zIndex,
                position: style.position,
                display: style.display
            });
            
            // Force enable pointer events on the entire panel
            controlsPanel.style.pointerEvents = 'auto';
            
            // Check and fix all interactive elements
            const selects = controlsPanel.querySelectorAll('select');
            const buttons = controlsPanel.querySelectorAll('button');
            const toggles = controlsPanel.querySelectorAll('.toggle-option');
            const inputs = controlsPanel.querySelectorAll('input');
            
            console.log(`Found: ${selects.length} selects, ${buttons.length} buttons, ${toggles.length} toggles, ${inputs.length} inputs`);
            
            // Force enable pointer events on all interactive elements
            [...selects, ...buttons, ...toggles, ...inputs].forEach(el => {
                el.style.pointerEvents = 'auto';
                el.style.cursor = 'pointer';
            });
            
            // Test click handlers
            toggles.forEach((toggle, i) => {
                const currentHandler = toggle.onclick;
                console.log(`Toggle ${i} onclick:`, currentHandler ? 'has handler' : 'NO HANDLER');
            });
            
            console.log('✅ Controls panel fix complete');
        }
        
        window.showFullDebugInfo = function() {
            const info = [];
            
            if (camera && controls) {
                const pos = camera.position;
                const target = controls.target;
                info.push(`📍 CAMERA POSITION:`);
                info.push(`Position: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);
                info.push(`Target: (${target.x.toFixed(2)}, ${target.y.toFixed(2)}, ${target.z.toFixed(2)})`);
                info.push(`Distance: ${pos.distanceTo(target).toFixed(2)}`);
                info.push(``);
            }
            
            if (renderer) {
                const rInfo = renderer.info;
                info.push(`⚡ PERFORMANCE:`);
                info.push(`FPS: ${performanceMonitor.fps}`);
                info.push(`Triangles: ${rInfo.render.triangles.toLocaleString()}`);
                info.push(`Draw Calls: ${rInfo.render.calls}`);
                info.push(`Geometries: ${rInfo.memory.geometries}`);
                info.push(`Textures: ${rInfo.memory.textures}`);
                info.push(``);
            }
            
            info.push(`🌐 SYSTEM:`);
            info.push(`Three.js: r${THREE.REVISION}`);
            info.push(`WebGL: ${renderer.capabilities.isWebGL2 ? '2.0' : '1.0'}`);
            info.push(`Max Texture Size: ${renderer.capabilities.maxTextureSize}`);
            info.push(`Screen: ${window.innerWidth}x${window.innerHeight}`);
            info.push(`Device Pixel Ratio: ${window.devicePixelRatio}`);
            
            alert(info.join('\n'));
        };
        
        // Initialize
        updateModelStatus('🚀 Starting enhanced 3D map environment...');
        initMap();
        
        // Animation helper object and easing functions are declared above with other globals
        
        function totalDuration() {
            return animationHelper.durations.reduce((a,b)=>a+b, 0) || 0;
        }

        function fmtVec(v) { return `${v.x.toFixed(1)},${v.y.toFixed(1)},${v.z.toFixed(1)}`; }

        function addKeyframe() {
            if (!camera || !controls) return;
            const kf = {
                id: Date.now() + Math.random(),
                position: camera.position.clone(),
                target: controls.target.clone(),
                timestamp: Date.now()
            };
            animationHelper.keyframes.push(kf);
            const count = animationHelper.keyframes.length;
            if (count > 1 && animationHelper.durations.length < count - 1) {
                animationHelper.durations.push(2000); // default 2s segment
            }
            status(`Keyframe ${count} added.`);
            updateKeyframeList();
            document.getElementById('kf-reset-view').disabled = animationHelper.keyframes.length === 0;
        }

        function removeKeyframe(id) {
            if (animationHelper.playing) return;
            const idx = animationHelper.keyframes.findIndex(k => k.id === id);
            if (idx === -1) return;
            animationHelper.keyframes.splice(idx,1);
            if (idx < animationHelper.durations.length) {
                animationHelper.durations.splice(idx,1); // remove corresponding segment
            } else if (idx === animationHelper.keyframes.length) {
                animationHelper.durations.pop();
            }
            status('Keyframe removed.');
            updateKeyframeList();
            if (animationHelper.keyframes.length === 0) {
                document.getElementById('kf-reset-view').disabled = true;
            }
        }

        function clearKeyframes() {
            if (animationHelper.playing) return;
            animationHelper.keyframes = [];
            animationHelper.durations = [];
            animationHelper.elapsedBeforePause = 0;
            animationHelper.playing = false;
            animationHelper.paused = false;
            updateKeyframeList();
            document.getElementById('kf-progress').value = 0;
            document.getElementById('kf-scrub').value = 0;
            document.getElementById('kf-time').textContent = '0.0s';
            document.getElementById('kf-play').disabled = true;
            document.getElementById('kf-pause').disabled = true;
            document.getElementById('kf-stop').disabled = true;
            document.getElementById('kf-reset-view').disabled = true;
            status('All keyframes cleared.');
        }

        function updateKeyframeList() {
            const list = document.getElementById('kf-list');
            const empty = document.getElementById('kf-empty');
            list.querySelectorAll('li:not(.empty-state)').forEach(li => li.remove());
            const k = animationHelper.keyframes;
            empty.style.display = k.length === 0 ? 'block' : 'none';
            k.forEach((kf, i) => {
                const li = document.createElement('li');
                const row = document.createElement('div');
                row.className = 'kf-row';
                const label = document.createElement('span');
                label.innerHTML = `KF ${i+1}`;
                const meta = document.createElement('span');
                meta.className = 'meta';
                meta.textContent = `pos(${fmtVec(kf.position)}) → tgt(${fmtVec(kf.target)})`;
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-kf';
                removeBtn.textContent = '✖';
                removeBtn.title = 'Remove keyframe';
                removeBtn.addEventListener('click', () => removeKeyframe(kf.id));
                row.appendChild(label);
                row.appendChild(meta);
                row.appendChild(removeBtn);
                li.appendChild(row);
                // Segment settings except for last keyframe
                if (i < k.length - 1) {
                    const seg = document.createElement('div');
                    seg.className = 'segment-settings';
                    seg.innerHTML = `<span>→ KF ${i+2} duration</span>`;
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = '100';
                    input.step = '100';
                    input.value = animationHelper.durations[i] || 2000;
                    input.title = 'Segment duration (ms)';
                    input.addEventListener('change', () => {
                        const v = parseInt(input.value) || 1000;
                        animationHelper.durations[i] = Math.max(50, v);
                        status(`Segment ${i+1} duration set to ${animationHelper.durations[i]} ms`);
                    });
                    seg.appendChild(input);
                    li.appendChild(seg);
                }
                list.appendChild(li);
            });
            const canPlay = animationHelper.keyframes.length >= 2 && !animationHelper.playing;
            document.getElementById('kf-play').disabled = !canPlay;
            document.getElementById('kf-stop').disabled = animationHelper.keyframes.length < 2;
            document.getElementById('kf-reset-view').disabled = animationHelper.keyframes.length === 0;
        }

        function lerp(a, b, t) { return a + (b - a) * t; }
        function lerpVec(a, b, t) { return new THREE.Vector3( lerp(a.x,b.x,t), lerp(a.y,b.y,t), lerp(a.z,b.z,t) ); }

        function evaluatePath(tNorm) {
            // tNorm in [0,1]
            const k = animationHelper.keyframes;
            if (k.length === 0) return null;
            if (k.length === 1) return { position: k[0].position.clone(), target: k[0].target.clone() };
            const total = totalDuration();
            if (!total) return { position: k[0].position.clone(), target: k[0].target.clone() };
            const tAbs = tNorm * total;
            let acc = 0;
            for (let i=0; i<k.length-1; i++) {
                const segDur = animationHelper.durations[i];
                if (tAbs <= acc + segDur || i === k.length-2) {
                    const localT = Math.min(1, (tAbs - acc) / segDur);
                    const ease = EASING[animationHelper.easing] || EASING.linear;
                    const et = ease(localT);
                    return {
                        position: lerpVec(k[i].position, k[i+1].position, et),
                        target: lerpVec(k[i].target, k[i+1].target, et)
                    };
                }
                acc += segDur;
            }
            return { position: k[k.length-1].position.clone(), target: k[k.length-1].target.clone() };
        }

        function applyPathSample(sample) {
            if (!sample) return;
            // Skip applying if user is actively interacting (prevents fighting controls)
            if (animationHelper._userInteracting) return;
            camera.position.copy(sample.position);
            controls.target.copy(sample.target);
            camera.lookAt(sample.target);
            controls.update();
        }

        function playAnimation() {
            if (animationHelper.keyframes.length < 2 || animationHelper.playing) return;
            animationHelper.suppressNextInteraction = true; // ignore the click
            setTimeout(() => { animationHelper.suppressNextInteraction = false; }, 150);
            animationHelper._userInteracting = false;
            animationHelper.playing = true;
            animationHelper.paused = false;
            animationHelper.startTime = performance.now();
            animationHelper.interactionGraceUntil = animationHelper.startTime + 500; // grace period: prior drags won't cancel
            animationHelper.elapsedBeforePause = 0;
            document.getElementById('kf-play').disabled = true;
            document.getElementById('kf-pause').disabled = false;
            document.getElementById('kf-stop').disabled = false;
            status('Playing animation...');
            animatePlayback();
        }

        function pauseAnimation() {
            if (!animationHelper.playing) return;
            if (!animationHelper.paused) {
                animationHelper.paused = true;
                animationHelper.elapsedBeforePause += performance.now() - animationHelper.startTime;
                if (animationHelper.rafId) cancelAnimationFrame(animationHelper.rafId);
                status('Paused.');
                document.getElementById('kf-pause').textContent = '▶️';
            } else {
                animationHelper.paused = false;
                animationHelper.startTime = performance.now();
                status('Resuming...');
                document.getElementById('kf-pause').textContent = '⏸️';
                animatePlayback();
            }
        }

        function stopAnimation() {
            if (animationHelper.rafId) cancelAnimationFrame(animationHelper.rafId);
            animationHelper.playing = false;
            animationHelper.paused = false;
            animationHelper.elapsedBeforePause = 0;
            document.getElementById('kf-play').disabled = animationHelper.keyframes.length < 2;
            document.getElementById('kf-pause').disabled = true;
            document.getElementById('kf-pause').textContent = '⏸️';
            document.getElementById('kf-stop').disabled = animationHelper.keyframes.length < 2;
            document.getElementById('kf-progress').value = 0;
            document.getElementById('kf-scrub').value = 0;
            document.getElementById('kf-time').textContent = '0.0s';
            if (animationHelper.keyframes[0]) applyPathSample({ position: animationHelper.keyframes[0].position, target: animationHelper.keyframes[0].target });
            status('Stopped.');
        }

        function animatePlayback() {
            const progressEl = document.getElementById('kf-progress');
            const scrubEl = document.getElementById('kf-scrub');
            const timeEl = document.getElementById('kf-time');
            const total = totalDuration();
            let interactingFrames = 0; // consecutive frames seen as interacting
            const step = (now) => {
                if (!animationHelper.playing || animationHelper.paused) return;
                // Respect grace window after pressing Play
                const withinGrace = animationHelper.interactionGraceUntil && now < animationHelper.interactionGraceUntil;
                if (animationHelper._userInteracting && !withinGrace) {
                    interactingFrames++;
                    if (interactingFrames >= 4) { // require sustained interaction (~4 rAF frames)
                        stopAnimation();
                        status('Animation stopped by user interaction.');
                        return;
                    }
                } else {
                    interactingFrames = 0;
                }
                const elapsed = animationHelper.elapsedBeforePause + (now - animationHelper.startTime);
                const clamped = Math.min(elapsed, total);
                const tNorm = total ? clamped / total : 0;
                progressEl.value = tNorm;
                scrubEl.value = tNorm;
                timeEl.textContent = (clamped/1000).toFixed(1)+'s';
                applyPathSample(evaluatePath(tNorm));
                if (clamped >= total) {
                    animationHelper.playing = false;
                    document.getElementById('kf-play').disabled = false;
                    document.getElementById('kf-pause').disabled = true;
                    status('Animation complete.');
                } else {
                    animationHelper.rafId = requestAnimationFrame(step);
                }
            };
            animationHelper.rafId = requestAnimationFrame(step);
        }

        function scrubTo(tNorm, fromUser=false) {
            if (fromUser && animationHelper.playing) {
                // Stop playback if user scrubs
                stopAnimation();
            }
            tNorm = Math.min(1, Math.max(0, tNorm));
            document.getElementById('kf-progress').value = tNorm;
            document.getElementById('kf-scrub').value = tNorm;
            const total = totalDuration();
            document.getElementById('kf-time').textContent = (tNorm * total / 1000).toFixed(1)+'s';
            applyPathSample(evaluatePath(tNorm));
        }

        function status(msg) {
            const el = document.getElementById('kf-status');
            if (el) el.textContent = msg;
        }

        function resetViewToFirst() {
            if (animationHelper.keyframes[0]) {
                applyPathSample(animationHelper.keyframes[0]);
                document.getElementById('kf-progress').value = 0;
                document.getElementById('kf-scrub').value = 0;
                document.getElementById('kf-time').textContent = '0.0s';
                status('Moved to first keyframe.');
            }
        }

        function initAnimationHelperUI() {
            const addBtn = document.getElementById('kf-add');
            const clearBtn = document.getElementById('kf-clear');
            const playBtn = document.getElementById('kf-play');
            const pauseBtn = document.getElementById('kf-pause');
            const stopBtn = document.getElementById('kf-stop');
            const easeSelect = document.getElementById('kf-ease');
            const scrub = document.getElementById('kf-scrub');
            const resetBtn = document.getElementById('kf-reset-view');
            // Phase 3 elements
            const saveBtn = document.getElementById('anim-save');
            const nameInput = document.getElementById('anim-name');
            const listSelect = document.getElementById('anim-list');
            const loadBtn = document.getElementById('anim-load');
            const renameBtn = document.getElementById('anim-rename');
            const deleteBtn = document.getElementById('anim-delete');
            const refreshBtn = document.getElementById('anim-refresh');
            if (!addBtn) return;
            addBtn.addEventListener('click', addKeyframe);
            clearBtn.addEventListener('click', clearKeyframes);
            playBtn.addEventListener('click', playAnimation);
            pauseBtn.addEventListener('click', pauseAnimation);
            stopBtn.addEventListener('click', stopAnimation);
            resetBtn.addEventListener('click', resetViewToFirst);
            easeSelect.addEventListener('change', () => {
                animationHelper.easing = easeSelect.value;
                status(`Easing set to ${easeSelect.value}`);
            });
            scrub.addEventListener('input', (e) => scrubTo(parseFloat(e.target.value), true));
            // Enable save when there are >=2 keyframes
            const updateSaveState = () => { saveBtn.disabled = animationHelper.keyframes.length < 2; };
            const origUpdateKF = updateKeyframeList;
            updateKeyframeList = function() { origUpdateKF(); updateSaveState(); };
            // Persistence logic
            refreshBtn.addEventListener('click', populateSavedAnimations);
            saveBtn.addEventListener('click', () => {
                const name = (nameInput.value || '').trim();
                if (!name) { status('Enter a name before saving.'); return; }
                saveCurrentAnimation(name);
            });
            loadBtn.addEventListener('click', () => {
                const sel = listSelect.value; if (!sel) return; loadAnimation(sel); });
            renameBtn.addEventListener('click', () => {
                const sel = listSelect.value; if (!sel) return;
                const newName = prompt('New animation name:', sel);
                if (newName && newName.trim() && newName !== sel) { renameAnimation(sel, newName.trim()); }
            });
            deleteBtn.addEventListener('click', () => {
                const sel = listSelect.value; if (!sel) return;
                if (confirm(`Delete animation "${sel}"?`)) { deleteAnimation(sel); }
            });
            listSelect.addEventListener('change', () => {
                const has = !!listSelect.value;
                loadBtn.disabled = !has;
                renameBtn.disabled = !has;
                deleteBtn.disabled = !has;
            });
            populateSavedAnimations();
            updateKeyframeList();
        }

        // ---- Phase 3 persistence helpers ----
        const STORAGE_KEY = 'animationHelperLibrary_v1';

        function loadLibrary() {
            try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); } catch { return {}; }
        }
        function saveLibrary(lib) {
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify(lib)); } catch (e) { console.warn('Persist failed', e); }
        }
        function serializeCurrent() {
            return {
                keyframes: animationHelper.keyframes.map(k => ({
                    position: { x:k.position.x, y:k.position.y, z:k.position.z },
                    target: { x:k.target.x, y:k.target.y, z:k.target.z },
                    timestamp: k.timestamp
                })),
                durations: [...animationHelper.durations],
                easing: animationHelper.easing,
                savedAt: Date.now()
            };
        }
        function deserializeInto(data) {
            if (!data) return;
            animationHelper.keyframes = data.keyframes.map(k => ({
                id: Date.now()+Math.random(),
                position: new THREE.Vector3(k.position.x, k.position.y, k.position.z),
                target: new THREE.Vector3(k.target.x, k.target.y, k.target.z),
                timestamp: k.timestamp || Date.now()
            }));
            animationHelper.durations = Array.isArray(data.durations) ? data.durations.slice() : [];
            animationHelper.easing = data.easing || 'linear';
            document.getElementById('kf-ease').value = animationHelper.easing;
            updateKeyframeList();
            scrubTo(0);
            status('Animation loaded.');
        }
        function saveCurrentAnimation(name) {
            const lib = loadLibrary();
            lib[name] = serializeCurrent();
            saveLibrary(lib);
            populateSavedAnimations(name);
            status(`Saved animation "${name}".`);
        }
        function loadAnimation(name) {
            const lib = loadLibrary();
            if (!lib[name]) { status('Animation not found.'); return; }
            deserializeInto(lib[name]);
        }
        function renameAnimation(oldName, newName) {
            const lib = loadLibrary();
            if (!lib[oldName]) { status('Animation not found.'); return; }
            if (lib[newName]) { status('Name already exists.'); return; }
            lib[newName] = lib[oldName];
            delete lib[oldName];
            saveLibrary(lib);
            populateSavedAnimations(newName);
            status(`Renamed to "${newName}".`);
        }
        function deleteAnimation(name) {
            const lib = loadLibrary();
            if (lib[name]) { delete lib[name]; saveLibrary(lib); }
            populateSavedAnimations();
            status(`Deleted "${name}".`);
        }
        function populateSavedAnimations(selectName='') {
            const listSelect = document.getElementById('anim-list');
            if (!listSelect) return;
            const lib = loadLibrary();
            const names = Object.keys(lib).sort((a,b)=>a.localeCompare(b));
            listSelect.innerHTML = '<option value="">(none)</option>' + names.map(n=>`<option value="${n}">${n}</option>`).join('');
            listSelect.value = names.includes(selectName) ? selectName : '';
            const has = !!listSelect.value;
            document.getElementById('anim-load').disabled = !has;
            document.getElementById('anim-rename').disabled = !has;
            document.getElementById('anim-delete').disabled = !has;
        }

        setTimeout(initAnimationHelperUI, 140);

        // Auto-discover models after initialization
        setTimeout(discoverModels, 1200);
    </script>
</body>
</html>
