<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Testing Suite</title>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow-x: hidden;
            background: #000000;
            font-size: 14px;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .page_wrap {
            position: relative;
            z-index: 10;
            pointer-events: auto;
        }
        
        .test-header {
            position: fixed;
            top: 24px;
            left: 24px;
            width: auto;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.98);
            padding: 24px 32px;
            border-radius: 20px;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.12),
                0 8px 16px rgba(0, 0, 0, 0.08),
                0 0 0 1px rgba(255, 255, 255, 0.05);
            z-index: 100;
            backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .test-header h1 {
            font-size: 28px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
        }
        
        .test-header p {
            color: #6b7280;
            font-size: 15px;
            font-weight: 400;
            line-height: 1.6;
            margin: 0;
        }
        
        .test-header p:last-child {
            margin-top: 4px;
            font-weight: 500;
            color: #374151;
        }
        
        .info-panels {
            position: fixed;
            bottom: 32px;
            left: 32px;
            display: flex;
            gap: 24px;
            z-index: 100;
            align-items: flex-end;
            /* Make gaps transparent to pointer events; panels explicitly re-enable */
            pointer-events: none;
        }
        .info-panels > .info-panel { pointer-events: auto; }
        /* Utility class to disable pass-through entirely if needed (toggle via JS) */
        .info-panels.no-pass-through { pointer-events: auto; }
        .info-panels.no-pass-through > .info-panel { pointer-events: auto; }
        /* Prevent accidental text selection while dragging over left-side panels */
        .info-panels, .info-panels .info-panel, .info-panels .info-panel *:not(input):not(textarea):not(select) {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        /* Allow normal selection/editing inside form fields */
        .info-panels input, .info-panels textarea, .info-panels select { 
            -webkit-user-select: text; 
            -moz-user-select: text; 
            -ms-user-select: text; 
            user-select: text; 
        }
        /* Allow text selection on copyable elements for fallback clipboard functionality */
        .info-panels .copyable {
            -webkit-user-select: text; 
            -moz-user-select: text; 
            -ms-user-select: text; 
            user-select: text; 
        }
        
        .info-panel {
            background: rgba(31, 41, 55, 0.85);
            color: #e5e7eb;
            padding: 28px 32px;
            border-radius: 16px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.7;
            flex: 1;
            width: auto;
            max-height: auto;
            overflow-y: auto;
            border: 1px solid rgba(75, 85, 99, 0.4);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.1, 1);
            transform-origin: bottom;
            backdrop-filter: blur(12px);
        }

        /* Specific sizing and ordering for panels */
        #camera-panel,
        #performance-panel {
            flex: 0 0 auto;
            width: 320px; /* default width */
            height: auto; /* dynamic height */
            max-height: 340px;
            overflow-y: auto; /* allow scroll if long */
        }
        /* Animation helper panel should expand to fit contents without its own scrollbar */
        #animation-helper-panel {
            flex: 0 0 auto;
            width: 320px;
            height: auto;
            max-height: none;
            overflow-y: visible;
        }

        #model-status-panel {
            flex: 0 0 auto;
            width: 420px; /* default width */
            height: 300px; /* fixed height to match others */
            max-height: 300px;
            overflow-y: hidden;
        }

        /* Make status the last panel in the row */
    #animation-helper-panel { order: 1; }
    #camera-panel { order: 2; }
    #performance-panel { order: 3; }
    #model-status-panel { order: 4; }
        
    
        
        .info-panel h3 {
            color: #f9fafb;
            margin-bottom: 20px;
            font-size: 15px;
            border-bottom: 2px solid rgba(107, 114, 128, 0.3);
            padding-bottom: 12px;
            font-weight: 700;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            letter-spacing: -0.2px;
            transition: color 0.3s ease;
            cursor: pointer;
        }
        
        .minimize-btn {
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            line-height: 1;
        }
        
        .minimize-btn:hover {
            background: rgba(156, 163, 175, 0.2);
            color: #d1d5db;
            transform: scale(1.1);
        }
        
        .panel-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .panel-content.minimized {
            height: 0 !important;
            max-height: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
            opacity: 0;
            overflow: hidden;
        }

        /* Animation Helper specific styles (Phase 1) */
        #animation-helper-panel .panel-content { display: flex; flex-direction: column; gap: 10px; }
    #animation-helper-panel .kf-buttons { display: flex; flex-wrap: wrap; gap: 6px; }
    #animation-helper-panel .kf-buttons .btn { flex: 1 1 auto; }
    #animation-helper-panel ul.keyframe-list { list-style: none; padding: 0; margin: 6px 0 0; font-size: 11px; line-height: 1.35; }
    #animation-helper-panel ul.keyframe-list li { padding: 6px 8px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1); border-radius: 5px; margin-bottom: 6px; display: flex; flex-direction: column; gap: 4px; position: relative; }
    #animation-helper-panel ul.keyframe-list li .kf-row { display: flex; justify-content: space-between; gap: 6px; align-items: center; }
    #animation-helper-panel ul.keyframe-list li span.meta { opacity: 0.7; font-size: 10px; }
    #animation-helper-panel ul.keyframe-list li button.remove-kf { background: none; border: none; color: #f87171; cursor: pointer; font-size: 14px; line-height: 1; padding: 2px 4px; }
    #animation-helper-panel ul.keyframe-list li button.remove-kf:hover { color: #dc2626; }
    #animation-helper-panel .segment-settings { display: flex; align-items: center; gap: 6px; font-size: 10px; }
    #animation-helper-panel .segment-settings input { width: 68px; padding: 2px 4px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.15); border-radius: 4px; color: #eee; font-size: 10px; }
    #animation-helper-panel .segment-settings input:focus { outline: none; border-color: #60a5fa; }
    #animation-helper-panel .playback-controls { display: flex; gap: 6px; }
    #animation-helper-panel .playback-row { display: flex; flex-direction: column; gap: 6px; }
    #animation-helper-panel .playback-progress { display: flex; align-items: center; gap: 6px; }
    #animation-helper-panel .playback-progress progress { flex: 1 1 auto; height: 8px; }
    #animation-helper-panel progress { width: 100%; }
    #animation-helper-panel .scrubber-row { display: flex; gap: 6px; align-items: center; }
    #animation-helper-panel .scrubber-row input[type=range] { flex: 1 1 auto; }
    #animation-helper-panel select#kf-ease { width: 100%; padding: 4px 6px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.15); color: #eee; border-radius: 4px; font-size: 11px; }
    #animation-helper-panel select#kf-ease:focus { outline: none; border-color: #60a5fa; }
        #animation-helper-panel .empty-state { font-size: 11px; opacity: 0.6; }
        #animation-helper-panel .status-line { font-size: 10px; opacity: 0.7; }
        #animation-helper-panel button.btn[disabled] { opacity: 0.4; cursor: not-allowed; }
    #animation-helper-panel .library-row { display:flex; gap:6px; margin-top:8px; }
    #animation-helper-panel .library-row input { flex:1 1 auto; padding:4px 6px; background: rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.15); color:#eee; border-radius:4px; font-size:11px; }
    #animation-helper-panel .library-row input:focus { outline:none; border-color:#60a5fa; }
    #animation-helper-panel .saved-animations { margin-top:8px; }
    #animation-helper-panel .saved-animations select { width:100%; padding:4px 6px; background: rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.15); color:#eee; border-radius:4px; font-size:11px; }
    #animation-helper-panel .saved-animations select:focus { outline:none; border-color:#60a5fa; }
    
        .info-panel.minimized {
            min-height: auto;
            height: auto !important;
            padding: 12px 16px;
        }
        
        .info-panel.minimized h3 {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
            font-size: 13px;
        }
        
        .controls-panel.minimized {
            padding: 12px 16px;
        }
        
        .controls-panel.minimized h3 {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
            font-size: 16px;
        }
        
        .controls-panel.minimized .refresh-icon {
            width: 28px;
            height: 28px;
            font-size: 14px;
        }
        
        .controls-panel {
            background: rgba(31, 41, 55, 0.85);
            color: #e5e7eb;
            padding: 36px 40px;
            border-radius: 20px;
            width: 750px;
            position: fixed;
            bottom: 32px;
            right: 32px;
            z-index: 100;
            pointer-events: auto; /* Explicitly enable pointer events */
            backdrop-filter: blur(12px);
            border: 1px solid rgba(75, 85, 99, 0.4);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.2);
            max-height: calc(100vh - 220px);
            overflow-y: auto;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.1, 1);
        }
        
        .controls-panel h3 {
            color: #f9fafb;
            margin-bottom: 28px;
            font-size: 22px;
            font-weight: 800;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            border-bottom: 3px solid rgba(107, 114, 128, 0.3);
            padding-bottom: 16px;
            letter-spacing: -0.4px;
            position: relative;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
        }
        
        .controls-panel h3::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 40px;
            height: 3px;
            background: linear-gradient(90deg, #6b7280, #9ca3af);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Quick UI hide mode */
        body.ui-hidden .info-panels,
        body.ui-hidden .controls-panel,
        body.ui-hidden .test-header { display: none !important; }
        body.ui-hidden #toast { display: none !important; }
        body.ui-hidden::after {
            content: 'UI Hidden (press H to toggle)';
            position: fixed; top: 8px; right: 12px; z-index: 9999;
            background: rgba(0,0,0,0.5); color:#fff; font: 12px/1.4 -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
            padding: 6px 10px; border-radius: 6px; letter-spacing: .5px;
        }

        .controls-panel:hover h3::after {
            width: 80px;
        }
        
        .mode-toggle {
            margin-bottom: 28px;
            padding: 24px;
            background: rgba(55, 65, 81, 0.6);
            border-radius: 16px;
            border: 1px solid rgba(75, 85, 99, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
        }
        
        .mode-toggle:hover {
            background: rgba(55, 65, 81, 0.8);
            border-color: rgba(75, 85, 99, 0.6);
            transform: translateY(-1px);
        }
        
        .mode-toggle > div:first-child {
            font-size: 12px;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .toggle-switch {
            display: flex;
            background: rgba(17, 24, 39, 0.6);
            border-radius: 12px;
            padding: 4px;
            margin-top: 0;
        }

        .tips-box {
            margin-top: 12px;
            padding: 12px 14px;
            background: rgba(31, 41, 55, 0.5);
            border: 1px dashed rgba(156, 163, 175, 0.35);
            border-radius: 12px;
            color: #e5e7eb;
            font-size: 12px;
        }
        .tips-box b { color: #f9fafb; }
        .tips-box ul { margin: 6px 0 0 16px; }
        .tips-box li { margin: 4px 0; }
        
        .toggle-option {
            flex: 1;
            padding: 12px 16px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.1, 1);
            font-size: 13px;
            font-weight: 600;
            color: #6b7280;
            position: relative;
            overflow: hidden;
        }
        
        .toggle-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s ease;
        }
        
        .toggle-option:hover::before:not(.active) {
            left: 100%;
        }
        
        .toggle-option.active {
            background: #374151;
            color: white;
            box-shadow: 
                0 6px 16px rgba(55, 65, 81, 0.3),
                0 3px 6px rgba(55, 65, 81, 0.2);
            transform: translateY(-2px) scale(1.02);
            animation: activeGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes activeGlow {
            from {
                box-shadow: 
                    0 6px 16px rgba(31, 41, 55, 0.2),
                    0 3px 6px rgba(31, 41, 55, 0.15);
            }
            to {
                box-shadow: 
                    0 8px 20px rgba(31, 41, 55, 0.25),
                    0 4px 8px rgba(31, 41, 55, 0.2);
            }
        }
        
        .toggle-option:hover:not(.active) {
            background: rgba(243, 244, 246, 0.8);
            color: #374151;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .comparison-panel {
            display: none;
            margin-bottom: 28px;
            padding: 24px;
            background: rgba(243, 244, 246, 0.8);
            border-radius: 16px;
            border: 1px solid rgba(209, 213, 219, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
            animation: slideIn 0.4s ease-out when visible;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .model-selector {
            margin-bottom: 16px;
        }
        
        .model-selector label {
            display: block;
            font-size: 12px;
            margin-bottom: 8px;
            color: #4b5563;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .model-selector select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.9);
            color: #1f2937;
            border: 1px solid rgba(209, 213, 219, 0.6);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.1, 1);
            cursor: pointer;
            position: relative;
        }
        
        .model-selector select:focus {
            outline: none;
            border-color: #1f2937;
            box-shadow: 
                0 0 0 4px rgba(31, 41, 55, 0.1),
                0 4px 12px rgba(0, 0, 0, 0.08);
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
            animation: focusPulse 0.3s ease-out;
        }
        
        @keyframes focusPulse {
            0% {
                box-shadow: 
                    0 0 0 0 rgba(31, 41, 55, 0.4),
                    0 4px 12px rgba(0, 0, 0, 0.08);
            }
            50% {
                box-shadow: 
                    0 0 0 6px rgba(31, 41, 55, 0.2),
                    0 4px 12px rgba(0, 0, 0, 0.08);
            }
            100% {
                box-shadow: 
                    0 0 0 4px rgba(31, 41, 55, 0.1),
                    0 4px 12px rgba(0, 0, 0, 0.08);
            }
        }
        
        .model-selector select:hover {
            border-color: #9ca3af;
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .model-group {
            margin-bottom: 8px;
        }
        
        .model-group-label {
            font-size: 10px;
            color: #6c757d;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 8px 0 4px 0;
            padding-left: 4px;
        }
        
        .opacity-slider {
            margin: 20px 0;
            padding: 16px;
            background: rgba(229, 231, 235, 0.4);
            border-radius: 8px;
            border: 1px solid rgba(209, 213, 219, 0.3);
        }
        
        .opacity-slider > div:first-child {
            font-size: 12px;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 0;
        }
        
        .slider-label {
            font-size: 11px;
            color: #6b7280;
            min-width: 60px;
            font-weight: 600;
            text-align: center;
        }
        
        .slider {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to right, #ef4444 0%, #06b6d4 100%);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .slider:hover {
            height: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.2),
                0 0 0 2px rgba(31, 41, 55, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
            position: relative;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.3),
                0 0 0 4px rgba(31, 41, 55, 0.2);
            animation: thumbPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes thumbPulse {
            0%, 100% {
                box-shadow: 
                    0 8px 16px rgba(0, 0, 0, 0.3),
                    0 0 0 4px rgba(31, 41, 55, 0.2);
            }
            50% {
                box-shadow: 
                    0 8px 16px rgba(0, 0, 0, 0.3),
                    0 0 0 6px rgba(31, 41, 55, 0.3);
            }
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.2),
                0 0 0 2px rgba(31, 41, 55, 0.1);
        }
        
        .comparison-controls {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }
        
        .comparison-controls .btn {
            flex: 1;
            padding: 10px 12px;
            font-size: 12px;
            margin: 0;
        }
        
        .model-group-label {
            font-size: 11px;
            color: #6b7280;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin: 16px 0 12px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(156, 163, 175, 0.2);
            position: relative;
            transition: all 0.3s ease;
        }
        
        .model-group-label:hover {
            color: #374151;
            letter-spacing: 1px;
            transform: translateX(2px);
        }
        
        .model-group-label::before {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 32px;
            height: 2px;
            background: #1f2937;
            border-radius: 1px;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.1, 1);
        }
        
        .model-group-label:hover::before {
            width: 60px;
        }
        
        .single-model-controls {
            display: block;
        }
        
        .models-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .model-group {
            display: flex;
            flex-direction: column;
        }
        
        .utility-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 6px;
            margin-top: 16px;
        }
        
        .refresh-icon {
            position: static;
            background: rgba(107, 114, 128, 0.1);
            border: 1px solid rgba(107, 114, 128, 0.2);
            color: #6b7280;
            width: 32px;
            height: 32px;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .refresh-icon:hover {
            background: rgba(107, 114, 128, 0.2);
            border-color: rgba(107, 114, 128, 0.4);
            transform: rotate(180deg) scale(1.1);
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn {
            background: #374151;
            color: #e5e7eb;
            border: none;
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            margin: 0 0 6px 0;
            display: block;
            width: 100%;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.1, 1);
            border: 1px solid rgba(75, 85, 99, 0.3);
            position: relative;
            overflow: hidden;
            letter-spacing: 0.2px;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .btn.neutral {
            background: #6b7280;
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .btn.neutral:hover {
            background: #9ca3af;
            box-shadow: 
                0 4px 12px rgba(107, 114, 128, 0.2),
                0 2px 4px rgba(107, 114, 128, 0.15);
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 8px 20px rgba(0, 0, 0, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.2);
            background: #4b5563;
            border-color: rgba(107, 114, 128, 0.4);
        }
        
        .btn:active {
            transform: translateY(-1px) scale(0.98);
            box-shadow: 
                0 4px 8px rgba(75, 85, 99, 0.2);
            transition: all 0.1s ease;
        }
        
        .btn.success { 
            background: #059669;
            border-color: rgba(255, 255, 255, 0.1);
        }
        .btn.success:hover { 
            background: #047857;
            box-shadow: 
                0 8px 20px rgba(5, 150, 105, 0.25),
                0 4px 8px rgba(5, 150, 105, 0.15);
        }
        
        .btn.warning { 
            background: #d97706;
            color: white;
            border-color: rgba(255, 255, 255, 0.1);
        }
        .btn.warning:hover { 
            background: #b45309;
            box-shadow: 
                0 8px 20px rgba(217, 119, 6, 0.25),
                0 4px 8px rgba(217, 119, 6, 0.15);
        }
        
        .btn.danger { 
            background: #dc2626;
            border-color: rgba(255, 255, 255, 0.1);
        }
        .btn.danger:hover { 
            background: #b91c1c;
            box-shadow: 
                0 8px 20px rgba(220, 38, 38, 0.25),
                0 4px 8px rgba(220, 38, 38, 0.15);
        }
        
        .comparison-controls .btn {
            font-size: 12px;
            padding: 10px 16px;
        }
        
        .camera-info {
            color: #e5e7eb;
            font-weight: 500;
        }
        
        .camera-info div {
            margin: 10px 0;
            padding: 6px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(156, 163, 175, 0.1);
            transition: all 0.2s ease;
        }
        
        .camera-info div:last-child {
            border-bottom: none;
        }
        
        .camera-info div:hover {
            background: rgba(243, 244, 246, 0.3);
            padding: 6px 8px;
            border-radius: 6px;
            margin: 10px -8px;
        }
        
        .camera-info span {
            font-weight: 600;
            color: #059669;
        }
        
        .performance-info {
            color: #e5e7eb;
            font-weight: 500;
        }
        
        .performance-info div {
            margin: 10px 0;
            padding: 6px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(156, 163, 175, 0.1);
            transition: all 0.2s ease;
        }
        
        .performance-info div:last-child {
            border-bottom: none;
        }
        
        /* Tab Navigation Styles */
        .tab-navigation {
            display: flex;
            gap: 4px;
            margin-bottom: 20px;
            background: rgba(17, 24, 39, 0.4);
            border-radius: 12px;
            padding: 4px;
        }
        
        .tab-button {
            flex: 1;
            padding: 10px 16px;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
            color: #9CA3AF;
            background: transparent;
        }
        
        .tab-button.active {
            background: #374151;
            color: #F9FAFB;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        .tab-button:hover:not(.active) {
            background: rgba(55, 65, 81, 0.5);
            color: #E5E7EB;
        }
        
        .tab-content {
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Lighting Controls Redesign */
        .lighting-controls {
            color: #E5E7EB;
            display: grid;
            gap: 16px;
        }
        
        .light-card {
            background: rgba(17, 24, 39, 0.4);
            border-radius: 16px;
            border: 2px solid transparent;
            padding: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
            position: relative;
            overflow: hidden;
        }
        
        .light-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--accent-color);
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
        
        .light-card.disabled {
            opacity: 0.5;
            background: rgba(17, 24, 39, 0.2);
        }
        
        .light-card.disabled::before {
            opacity: 0.3;
        }
        
        /* Color coding for different light types */
        .warm-light {
            --accent-color: linear-gradient(90deg, #FFA500, #FF6347);
            border-color: rgba(255, 165, 0, 0.2);
        }
        
        .main-light {
            --accent-color: linear-gradient(90deg, #FFD700, #FFA500);
            border-color: rgba(255, 215, 0, 0.2);
        }
        
        .fill-light {
            --accent-color: linear-gradient(90deg, #87CEEB, #4682B4);
            border-color: rgba(135, 206, 235, 0.2);
        }
        
        .ambient-light {
            --accent-color: linear-gradient(90deg, #9370DB, #6A5ACD);
            border-color: rgba(147, 112, 219, 0.2);
        }
        
        .light-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .light-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .light-icon {
            font-size: 24px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .light-title h4 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #F9FAFB;
            letter-spacing: -0.2px;
        }
        
        /* Custom Toggle Switch */
        .light-toggle {
            position: relative;
            display: inline-block;
            width: 56px;
            height: 28px;
            cursor: pointer;
        }
        
        .light-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(55, 65, 81, 0.8);
            border: 2px solid rgba(75, 85, 99, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
            border-radius: 28px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background: #9CA3AF;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .light-toggle input:checked + .toggle-slider {
            background: linear-gradient(135deg, #10B981, #059669);
            border-color: rgba(16, 185, 129, 0.4);
        }
        
        .light-toggle input:checked + .toggle-slider:before {
            transform: translateX(26px);
            background: #FFFFFF;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .light-controls {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .intensity-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .intensity-control label {
            font-size: 13px;
            font-weight: 500;
            color: #D1D5DB;
        }
        
        .slider-with-value {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .slider-with-value input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: rgba(55, 65, 81, 0.8);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }
        
        .slider-with-value input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #60A5FA, #3B82F6);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
            border: 2px solid #FFFFFF;
        }
        
        .slider-with-value input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #60A5FA, #3B82F6);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
            border: 2px solid #FFFFFF;
        }
        
        .value-display {
            min-width: 40px;
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            color: #60A5FA;
            background: rgba(59, 130, 246, 0.1);
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid rgba(59, 130, 246, 0.2);
        }
        
        .color-controls {
            display: flex;
            gap: 16px;
        }
        
        .color-input-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .color-input-group label {
            font-size: 12px;
            font-weight: 500;
            color: #9CA3AF;
        }
        
        .color-picker-wrapper {
            position: relative;
            width: 50px;
            height: 50px;
            border-radius: 12px;
            overflow: hidden;
            border: 3px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .color-picker-wrapper:hover {
            border-color: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .color-picker-wrapper input[type="color"] {
            width: 100%;
            height: 100%;
            border: none;
            background: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .color-picker-wrapper input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        
        .color-picker-wrapper input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 8px;
        }
        
        .feature-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
            background: rgba(55, 65, 81, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(75, 85, 99, 0.3);
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: #D1D5DB;
        }
        
        .checkbox-label input[type="checkbox"] {
            appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid #6B7280;
            border-radius: 4px;
            background: rgba(17, 24, 39, 0.8);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .checkbox-label input[type="checkbox"]:checked {
            background: linear-gradient(135deg, #8B5CF6, #7C3AED);
            border-color: #8B5CF6;
        }
        
        .checkbox-label input[type="checkbox"]:checked::before {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        /* Animation Tab Redesign */
        .animation-controls {
            display: grid;
            gap: 20px;
        }
        
        .animation-card {
            background: rgba(17, 24, 39, 0.4);
            border-radius: 16px;
            border: 2px solid rgba(75, 85, 99, 0.2);
            padding: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
            position: relative;
        }
        
        .animation-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--card-accent);
            opacity: 0.8;
            transition: opacity 0.3s ease;
            border-radius: 16px 16px 0 0;
        }
        
        /* Color coding for different animation card types - muted colors */
        .keyframe-card {
            --card-accent: linear-gradient(90deg, #c17a11, #a16207);
        }
        
        .settings-card {
            --card-accent: linear-gradient(90deg, #6b7280, #4b5563);
        }
        
        .playback-card {
            --card-accent: linear-gradient(90deg, #c17a11, #a16207);
        }
        
        .library-card {
            --card-accent: linear-gradient(90deg, #6b7280, #4b5563);
        }
        
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .card-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .card-icon {
            font-size: 24px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        
        .card-title h4 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #F9FAFB;
            letter-spacing: -0.2px;
        }
        
        .keyframe-count, .playback-time {
            font-size: 13px;
            font-weight: 500;
            color: #9CA3AF;
            background: rgba(55, 65, 81, 0.6);
            padding: 4px 12px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.3);
        }
        
        .card-content {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        /* Action Buttons */
        .keyframe-actions, .library-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .action-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .action-btn.primary {
            background: rgba(193, 122, 17, 0.8);
            color: white;
            border: 1px solid rgba(193, 122, 17, 0.3);
        }
        
        .action-btn.primary:hover:not(:disabled) {
            background: rgba(193, 122, 17, 0.9);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(193, 122, 17, 0.2);
        }
        
        .action-btn.secondary {
            background: rgba(107, 114, 128, 0.6);
            color: #D1D5DB;
            border: 1px solid rgba(107, 114, 128, 0.3);
        }
        
        .action-btn.secondary:hover:not(:disabled) {
            background: rgba(107, 114, 128, 0.8);
            color: #F3F4F6;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(107, 114, 128, 0.2);
        }
        
        .action-btn.danger {
            background: rgba(185, 28, 28, 0.7);
            color: white;
            border: 1px solid rgba(185, 28, 28, 0.3);
        }
        
        .action-btn.danger:hover:not(:disabled) {
            background: rgba(185, 28, 28, 0.8);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(185, 28, 28, 0.2);
        }
        
        .action-btn.neutral {
            background: rgba(55, 65, 81, 0.6);
            color: #D1D5DB;
            border: 1px solid rgba(75, 85, 99, 0.4);
        }
        
        .action-btn.neutral:hover:not(:disabled) {
            background: rgba(75, 85, 99, 0.8);
            color: #F3F4F6;
            transform: translateY(-1px);
        }
        
        .action-btn.refresh {
            background: rgba(107, 114, 128, 0.4);
            color: #9CA3AF;
            border: 1px solid rgba(107, 114, 128, 0.3);
        }
        
        .action-btn.refresh:hover:not(:disabled) {
            background: rgba(107, 114, 128, 0.6);
            color: #D1D5DB;
            transform: translateY(-1px);
        }
        
        .btn-icon {
            font-size: 14px;
        }
        
        /* Keyframe List */
        .keyframe-list-container {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        .keyframe-list {
            padding: 8px;
        }
        
        .empty-keyframes {
            text-align: center;
            padding: 24px 16px;
            color: #9CA3AF;
        }
        
        .empty-icon {
            font-size: 32px;
            display: block;
            margin-bottom: 12px;
        }
        
        .empty-keyframes p {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #D1D5DB;
        }
        
        .empty-keyframes small {
            font-size: 12px;
            color: #9CA3AF;
        }
        
        .keyframe-item {
            background: rgba(55, 65, 81, 0.4);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }
        
        .keyframe-item:hover {
            background: rgba(75, 85, 99, 0.5);
            border-color: rgba(96, 165, 250, 0.4);
        }
        
        .keyframe-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .keyframe-title {
            font-size: 13px;
            font-weight: 600;
            color: #F3F4F6;
        }
        
        .keyframe-remove {
            background: none;
            border: none;
            color: #EF4444;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .keyframe-remove:hover {
            color: #DC2626;
            background: rgba(239, 68, 68, 0.1);
        }
        
        .keyframe-details {
            font-size: 11px;
            color: #9CA3AF;
            line-height: 1.4;
        }
        
        /* Settings */
        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-label {
            font-size: 13px;
            font-weight: 500;
            color: #D1D5DB;
        }
        
        .custom-select-wrapper {
            position: relative;
        }
        
        .custom-select {
            width: 100%;
            padding: 10px 14px;
            background: rgba(55, 65, 81, 0.8);
            border: 2px solid rgba(75, 85, 99, 0.4);
            border-radius: 8px;
            color: #F3F4F6;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%236B7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            padding-right: 40px;
        }
        
        .custom-select:focus {
            outline: none;
            border-color: #60A5FA;
            box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.1);
        }
        
        /* Scrubber Control */
        .scrubber-control {
            position: relative;
        }
        
        .timeline-scrubber {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(55, 65, 81, 0.8);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }
        
        .timeline-scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(193, 122, 17, 0.9);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(193, 122, 17, 0.3);
            border: 2px solid #FFFFFF;
        }
        
        .timeline-scrubber::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(193, 122, 17, 0.9);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(193, 122, 17, 0.3);
            border: 2px solid #FFFFFF;
        }
        
        .scrubber-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 10px;
            color: #9CA3AF;
        }
        
        /* Playback Controls */
        .playback-controls-main {
            display: flex;
            justify-content: center;
            gap: 12px;
        }
        
        .playback-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            position: relative;
            overflow: hidden;
        }
        
        .playback-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .playback-btn.play {
            background: rgba(193, 122, 17, 0.8);
            color: white;
            box-shadow: 0 4px 12px rgba(193, 122, 17, 0.2);
        }
        
        .playback-btn.play:hover:not(:disabled) {
            background: rgba(193, 122, 17, 0.9);
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(193, 122, 17, 0.3);
        }
        
        .playback-btn.pause {
            background: rgba(107, 114, 128, 0.8);
            color: white;
            box-shadow: 0 4px 12px rgba(107, 114, 128, 0.2);
        }
        
        .playback-btn.pause:hover:not(:disabled) {
            background: rgba(107, 114, 128, 0.9);
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(107, 114, 128, 0.3);
        }
        
        .playback-btn.stop {
            background: rgba(185, 28, 28, 0.7);
            color: white;
            box-shadow: 0 4px 12px rgba(185, 28, 28, 0.2);
        }
        
        .playback-btn.stop:hover:not(:disabled) {
            background: rgba(185, 28, 28, 0.8);
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(185, 28, 28, 0.3);
        }
        
        /* Progress Bar */
        .progress-container {
            margin: 16px 0;
        }
        
        .progress-bar-wrapper {
            width: 100%;
            height: 8px;
            background: rgba(55, 65, 81, 0.8);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(75, 85, 99, 0.3);
        }
        
        .progress-bar {
            width: 100%;
            height: 100%;
            background: transparent;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: rgba(193, 122, 17, 0.8);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        /* Animation Status */
        .animation-status {
            text-align: center;
            font-size: 12px;
            color: #9CA3AF;
            font-style: italic;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border: 1px solid rgba(75, 85, 99, 0.2);
        }
        
        /* Library Controls */
        .library-save {
            border-bottom: 1px solid rgba(75, 85, 99, 0.3);
            padding-bottom: 16px;
            margin-bottom: 16px;
        }
        
        .save-input-group {
            display: flex;
            gap: 8px;
        }
        
        .animation-input {
            flex: 1;
            padding: 10px 14px;
            background: rgba(55, 65, 81, 0.8);
            border: 2px solid rgba(75, 85, 99, 0.4);
            border-radius: 8px;
            color: #F3F4F6;
            font-size: 13px;
            transition: all 0.3s ease;
        }
        
        .animation-input:focus {
            outline: none;
            border-color: #60A5FA;
            box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.1);
        }
        
        .animation-input::placeholder {
            color: #9CA3AF;
        }
        
        .library-load {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .library-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .lighting-presets {
            margin-top: 24px;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }
        
        .preset-buttons .btn {
            margin: 0;
            font-size: 11px;
            padding: 8px 12px;
        }
        
        /* Mode Toggle Redesign */
        .mode-toggle {
            margin-bottom: 20px;
            padding: 16px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(147, 51, 234, 0.1));
            border: 2px solid rgba(59, 130, 246, 0.2);
            border-radius: 16px;
            position: relative;
        }
        
        .mode-toggle::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(147, 51, 234, 0.3));
            border-radius: 16px;
            z-index: -1;
            opacity: 0.5;
        }
        
        .mode-label {
            font-size: 13px;
            font-weight: 600;
            color: #E0E7FF;
            margin-bottom: 12px;
            text-align: center;
            letter-spacing: 0.5px;
        }
        
        .mode-switch {
            display: flex;
            gap: 6px;
            background: rgba(17, 24, 39, 0.6);
            border-radius: 12px;
            padding: 6px;
            border: 1px solid rgba(75, 85, 99, 0.3);
        }
        
        .mode-option {
            flex: 1;
            padding: 12px 20px;
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.1, 1);
            color: #9CA3AF;
            background: transparent;
            border: 1px solid transparent;
        }
        
        .mode-option.active {
            background: linear-gradient(135deg, #3B82F6, #8B5CF6);
            color: #FFFFFF;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }
        
        .mode-option:hover:not(.active) {
            background: rgba(59, 130, 246, 0.1);
            color: #E5E7EB;
            border: 1px solid rgba(59, 130, 246, 0.3);
            transform: translateY(-1px);
        }
        
        .performance-info div:hover {
            background: rgba(243, 244, 246, 0.3);
            padding: 6px 8px;
            border-radius: 6px;
            margin: 10px -8px;
        }
        
        .performance-info span {
            font-weight: 600;
            color: #d97706;
        }
        
        .model-info {
            color: #1f2937;
            font-weight: 500;
        }
        
        /* Loading States */
        .loading-indicator {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2.5px solid rgba(31, 41, 55, 0.1);
            border-radius: 50%;
            border-top-color: #1f2937;
            animation: spin 1.2s cubic-bezier(0.4, 0, 0.1, 1) infinite;
            margin-right: 10px;
            position: relative;
        }
        
        .loading-indicator::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border: 1px solid transparent;
            border-top-color: rgba(31, 41, 55, 0.3);
            border-radius: 50%;
            animation: spin 0.8s linear infinite reverse;
        }
        
        @keyframes spin {
            0% { 
                transform: rotate(0deg); 
            }
            50% { 
                transform: rotate(180deg); 
                border-width: 3px;
            }
            100% { 
                transform: rotate(360deg); 
                border-width: 2.5px;
            }
        }
        
        .status-success {
            color: #059669;
            font-weight: 600;
        }
        
        .status-error {
            color: #dc2626;
            font-weight: 600;
        }
        
        .status-loading {
            color: #d97706;
            font-weight: 600;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(156, 163, 175, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #059669, #10b981, #06b6d4);
            border-radius: 3px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.1, 1);
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: progressShine 1.5s ease-in-out infinite;
        }
        
        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
            100% { transform: translateX(100%); }
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .info-panels {
                flex-direction: column;
                bottom: 16px;
                left: 16px;
                right: 16px;
                gap: 12px;
            }
            
            /* On small screens, let panels size naturally */
            #camera-panel,
            #performance-panel,
            #model-status-panel {
                width: auto;
                height: auto;
                max-height: none;
                order: initial;
                flex: 1 1 auto;
                overflow-y: auto;
            }
            
            .controls-panel {
                position: static;
                width: auto;
                margin-top: 12px;
            }
            
            .test-header {
                position: static;
                margin: 16px;
                padding: 24px;
            }
            
            .test-header h1 {
                font-size: 24px;
            }
        }
        
        /* Scrollbar Styling */
        .info-panel::-webkit-scrollbar,
        .controls-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .info-panel::-webkit-scrollbar-track,
        .controls-panel::-webkit-scrollbar-track {
            background: rgba(156, 163, 175, 0.1);
            border-radius: 3px;
        }
        
        .info-panel::-webkit-scrollbar-thumb,
        .controls-panel::-webkit-scrollbar-thumb {
            background: rgba(156, 163, 175, 0.3);
            border-radius: 3px;
        }
        
        .info-panel::-webkit-scrollbar-thumb:hover,
        .controls-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(156, 163, 175, 0.5);
        }

        /* Toast */
        #toast {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: rgba(31, 41, 55, 0.96);
            color: #fff;
            padding: 10px 14px;
            border-radius: 10px;
            font-size: 12px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            z-index: 9999;
        }
        #toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Tips floating panel */
        .tips-panel {
            position: fixed;
            top: 32px; /* align with bottom panels padding */
            left: 32px; /* upper-left corner */
            background: rgba(31, 41, 55, 0.85);
            color: #e5e7eb;
            padding: 16px 16px;
            border-radius: 16px;
            width: auto;
            z-index: 110;
            border: 1px solid rgba(75, 85, 99, 0.4);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(12px);
        }
        .tips-panel h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 700;
            color: #f9fafb;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(107, 114, 128, 0.3);
            padding-bottom: 6px;
            cursor: pointer;
        }
        .tips-panel .panel-content { font-size: 12px; line-height: 1.5; }
        .tips-panel ul { margin: 6px 0 0 16px; }
        .tips-panel li { margin: 4px 0; }
        .tips-panel.minimized { padding: 10px 12px; }

        @media (max-width: 768px) {
            .tips-panel {
                top: 16px;
                left: 16px;
                right: auto;
                bottom: auto;
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="page_wrap">
        <!-- Floating Tips Panel -->
        <div class="tips-panel" id="tips-panel">
            <h3 onclick="togglePanel('tips-panel')">
                <span>💡 Usage Tips</span>
                <button class="minimize-btn" id="tips-btn">−</button>
            </h3>
            <div class="panel-content">
                <ul>
                    <li>Left mouse: Orbit</li>
                    <li>Right mouse: Pan</li>
                    <li>Scroll: Zoom</li>
                    <li>R: Reset camera</li>
                    <li>W: Toggle wireframe</li>
                    <li>H: Hide/show UI</li>
                </ul>
            </div>
        </div>
        
        <div class="info-panels">
            <div class="info-panel" id="model-status-panel">
                <h3 onclick="togglePanel('model-status-panel')">
                    <span>📊 Model Status</span>
                    <button class="minimize-btn" id="model-status-btn">−</button>
                </h3>
                <div class="panel-content" id="model-status">Ready to load models...</div>
            </div>
            
            <div class="info-panel" id="camera-panel">
                <h3 onclick="togglePanel('camera-panel')">
                    <span>📍 Camera Position</span>
                    <button class="minimize-btn" id="camera-btn">−</button>
                </h3>
                <div class="panel-content camera-info">
                    <div>Position: <span id="camera-position">--, --, --</span></div>
                    <div>Target: <span id="camera-target">--, --, --</span></div>
                    <div>Distance: <span id="camera-distance">--</span></div>
                    <div>Rotation: <span id="camera-rotation">--, --</span></div>
                </div>
            </div>

            <div class="info-panel" id="performance-panel">
                <h3 onclick="togglePanel('performance-panel')">
                    <span>⚡ Performance</span>
                    <button class="minimize-btn" id="performance-btn">−</button>
                </h3>
                <div class="panel-content performance-info">
                    <div>FPS: <span id="fps-counter">--</span></div>
                    <div>Triangles: <span id="triangle-count">--</span></div>
                    <div>Draw Calls: <span id="draw-calls">--</span></div>
                    <div>Memory: <span id="memory-usage">--</span></div>
                </div>
            </div>

        <!-- Toast container -->
        <div id="toast"></div>

        <div class="controls-panel" id="controls-panel">
            <h3 onclick="togglePanel('controls-panel')">
                <span>Model Controls</span>
                <span class="header-actions">
                    <div class="refresh-icon" onclick="event.stopPropagation(); discoverModels();" title="Refresh Models">🔄</div>
                    <button class="minimize-btn" id="controls-btn" onclick="event.stopPropagation(); togglePanel('controls-panel');">−</button>
                </span>
            </h3>
            <div class="panel-content" id="controls-content">
                
                <!-- Tab Navigation -->
                <div class="tab-navigation">
                    <div class="tab-button active" onclick="switchControlsTab('models')" id="models-tab">🎯 Models</div>
                    <div class="tab-button" onclick="switchControlsTab('animation')" id="animation-tab">🎬 Animation</div>
                    <div class="tab-button" onclick="switchControlsTab('lighting')" id="lighting-tab">💡 Lighting</div>
                    <div class="tab-button" onclick="switchControlsTab('config')" id="config-tab">⚙️ Config</div>
                </div>
                
                <!-- Models Tab Content -->
                <div class="tab-content" id="models-tab-content">
                
                <!-- Mode Toggle -->
                <div class="mode-toggle">
                    <div class="mode-label">Testing Mode:</div>
                    <div class="mode-switch">
                        <div class="mode-option active" onclick="setMode('single')" id="single-mode-btn">🎯 Single Model</div>
                        <div class="mode-option" onclick="setMode('comparison')" id="comparison-mode-btn">🔄 Comparison</div>
                    </div>
                </div>
                
                <!-- Comparison Mode Panel -->
                <div class="comparison-panel" id="comparison-panel">
                    <div class="model-selector">
                        <label>Model A (Red):</label>
                        <select id="model-a-select">
                            <!-- Options will be dynamically populated -->
                        </select>
                    </div>
                    
                    <div class="model-selector">
                        <label>Model B (Blue):</label>
                        <select id="model-b-select">
                            <!-- Options will be dynamically populated -->
                        </select>
                    </div>
                    
                    <div class="opacity-slider">
                        <div style="font-size: 11px; margin-bottom: 5px;">Quality Comparison:</div>
                        <div class="slider-container">
                            <span class="slider-label">Model A</span>
                            <input type="range" class="slider" id="opacity-slider" min="0" max="100" value="50" oninput="updateOpacity(this.value)">
                            <span class="slider-label">Model B</span>
                        </div>
                        <div style="text-align: center; font-size: 10px; color: #888; margin-top: 5px;">
                            Opacity: <span id="opacity-display">50%</span> A / <span id="opacity-display-b">50%</span> B
                        </div>
                    </div>
                    
                    <!-- Model Toggle -->
                    <div class="model-toggle" style="margin-bottom: 16px;">
                        <div style="font-size: 11px; margin-bottom: 5px;">Quick Toggle:</div>
                        <div class="toggle-switch">
                            <div class="toggle-option active" onclick="toggleToModel('A')" id="model-a-toggle">Model A</div>
                            <div class="toggle-option" onclick="toggleToModel('B')" id="model-b-toggle">Model B</div>
                        </div>
                    </div>
                    
                    <div class="comparison-controls">
                    </div>
                </div>
                
                <!-- Single Model Controls (Dynamically Generated) -->
                <div class="single-model-controls" id="single-model-controls">
                    <!-- Model buttons will be populated dynamically -->
                </div>
                
                <hr style="margin: 16px 0; border-color: #333;">
                <div class="utility-controls">
                    <button class="btn neutral" onclick="resetCamera()">📷 Reset Camera</button>
                    <button class="btn neutral" onclick="toggleWireframe()">🔧 Toggle Wireframe</button>
                    <button class="btn neutral" onclick="copyCurrentPosition()">📋 Copy Camera Position</button>
                    <button class="btn neutral" onclick="showFullDebugInfo()">🐛 Full Debug Info</button>
                </div>
                </div>
                
                <!-- Lighting Tab Content -->
                <div class="tab-content" id="lighting-tab-content" style="display: none;">
                    <div class="lighting-controls">
                        
                        <!-- Warm Light Card -->
                        <div class="light-card warm-light" id="warm-light-card">
                            <div class="light-header">
                                <div class="light-title">
                                    <span class="light-icon">🌅</span>
                                    <h4>Warm Ambient</h4>
                                </div>
                                <label class="light-toggle">
                                    <input type="checkbox" id="warm-enabled" checked onchange="updateWarmLight()">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="light-controls">
                                <div class="intensity-control">
                                    <label>Intensity</label>
                                    <div class="slider-with-value">
                                        <input type="range" id="warm-intensity" min="0" max="5" step="0.1" value="3.9" oninput="updateWarmLight()">
                                        <span class="value-display" id="warm-intensity-value">3.9</span>
                                    </div>
                                </div>
                                <div class="color-controls">
                                    <div class="color-input-group">
                                        <label>Sky</label>
                                        <div class="color-picker-wrapper">
                                            <input type="color" id="warm-sky-color" value="#fff5f5" onchange="updateWarmLight()">
                                        </div>
                                    </div>
                                    <div class="color-input-group">
                                        <label>Ground</label>
                                        <div class="color-picker-wrapper">
                                            <input type="color" id="warm-ground-color" value="#bd9a1f" onchange="updateWarmLight()">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Main Light Card -->
                        <div class="light-card main-light" id="main-light-card">
                            <div class="light-header">
                                <div class="light-title">
                                    <span class="light-icon">☀️</span>
                                    <h4>Main Light</h4>
                                </div>
                                <label class="light-toggle">
                                    <input type="checkbox" id="main-enabled" onchange="updateMainLight()">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="light-controls">
                                <div class="intensity-control">
                                    <label>Intensity</label>
                                    <div class="slider-with-value">
                                        <input type="range" id="main-intensity" min="0" max="5" step="0.1" value="1.0" oninput="updateMainLight()">
                                        <span class="value-display" id="main-intensity-value">1.0</span>
                                    </div>
                                </div>
                                <div class="feature-toggle">
                                    <label class="checkbox-label">
                                        <input type="checkbox" id="shadows-enabled" onchange="updateShadows()">
                                        <span class="checkmark"></span>
                                        Enable Shadows
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Fill Light Card -->
                        <div class="light-card fill-light" id="fill-light-card">
                            <div class="light-header">
                                <div class="light-title">
                                    <span class="light-icon">🌊</span>
                                    <h4>Fill Light</h4>
                                </div>
                                <label class="light-toggle">
                                    <input type="checkbox" id="fill-enabled" onchange="updateFillLight()">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="light-controls">
                                <div class="intensity-control">
                                    <label>Intensity</label>
                                    <div class="slider-with-value">
                                        <input type="range" id="fill-intensity" min="0" max="5" step="0.1" value="0.4" oninput="updateFillLight()">
                                        <span class="value-display" id="fill-intensity-value">0.4</span>
                                    </div>
                                </div>
                                <div class="color-controls">
                                    <div class="color-input-group">
                                        <label>Color</label>
                                        <div class="color-picker-wrapper">
                                            <input type="color" id="fill-color" value="#87ceeb" onchange="updateFillLight()">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Ambient Light Card -->
                        <div class="light-card ambient-light" id="ambient-light-card">
                            <div class="light-header">
                                <div class="light-title">
                                    <span class="light-icon">🌙</span>
                                    <h4>Ambient Light</h4>
                                </div>
                                <label class="light-toggle">
                                    <input type="checkbox" id="ambient-enabled" onchange="updateAmbientLight()">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="light-controls">
                                <div class="intensity-control">
                                    <label>Intensity</label>
                                    <div class="slider-with-value">
                                        <input type="range" id="ambient-intensity" min="0" max="5" step="0.1" value="0.6" oninput="updateAmbientLight()">
                                        <span class="value-display" id="ambient-intensity-value">0.6</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                <!-- Animation Tab Content -->
                <div class="tab-content" id="animation-tab-content" style="display: none;">
                    
                    <div class="animation-controls">
                        
                        <!-- Keyframe Management Card -->
                        <div class="animation-card keyframe-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <span class="card-icon">🎯</span>
                                    <h4>Keyframes</h4>
                                </div>
                                <div class="keyframe-count" id="keyframe-count">0 keyframes</div>
                            </div>
                            <div class="card-content">
                                <div class="keyframe-actions">
                                    <button class="action-btn primary" id="kf-add">
                                        <span class="btn-icon">➕</span>
                                        Add Keyframe
                                    </button>
                                    <button class="action-btn danger" id="kf-clear" title="Clear all keyframes">
                                        <span class="btn-icon">🗑️</span>
                                        Clear All
                                    </button>
                                    <button class="action-btn neutral" id="kf-reset-view" title="Go to first keyframe" disabled>
                                        <span class="btn-icon">⏮️</span>
                                        First
                                    </button>
                                </div>
                                
                                <!-- Keyframe List -->
                                <div class="keyframe-list-container">
                                    <div class="keyframe-list" id="kf-list">
                                        <div class="empty-keyframes" id="kf-empty">
                                            <span class="empty-icon">🎬</span>
                                            <p>No keyframes created yet</p>
                                            <small>Move the camera and click "Add Keyframe" to get started</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Animation Settings Card -->
                        <div class="animation-card settings-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <span class="card-icon">⚙️</span>
                                    <h4>Animation Settings</h4>
                                </div>
                            </div>
                            <div class="card-content">
                                <div class="setting-group">
                                    <label class="setting-label">Easing Function</label>
                                    <div class="custom-select-wrapper">
                                        <select id="kf-ease" class="custom-select">
                                            <option value="linear">Linear</option>
                                            <option value="easeIn">Ease In</option>
                                            <option value="easeOut">Ease Out</option>
                                            <option value="easeInOut">Ease InOut</option>
                                            <option value="bounce">Bounce</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <div class="setting-group">
                                    <label class="setting-label">Timeline Scrubber</label>
                                    <div class="scrubber-control">
                                        <input type="range" id="kf-scrub" min="0" max="1" step="0.0001" value="0" class="timeline-scrubber">
                                        <div class="scrubber-markers">
                                            <span>Start</span>
                                            <span>End</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Playback Controls Card -->
                        <div class="animation-card playback-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <span class="card-icon">▶️</span>
                                    <h4>Playback</h4>
                                </div>
                                <div class="playback-time" id="kf-time">0.0s</div>
                            </div>
                            <div class="card-content">
                                <div class="playback-controls-main">
                                    <button class="playback-btn play" id="kf-play" disabled title="Play Animation">
                                        <span class="btn-icon">▶️</span>
                                    </button>
                                    <button class="playback-btn pause" id="kf-pause" disabled title="Pause Animation">
                                        <span class="btn-icon">⏸️</span>
                                    </button>
                                    <button class="playback-btn stop" id="kf-stop" disabled title="Stop Animation">
                                        <span class="btn-icon">⏹️</span>
                                    </button>
                                </div>
                                
                                <div class="progress-container">
                                    <div class="progress-bar-wrapper">
                                        <div class="progress-bar" id="kf-progress-bar">
                                            <div class="progress-fill" id="kf-progress-fill"></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="animation-status" id="kf-status">
                                    Add 2+ keyframes to enable playback
                                </div>
                            </div>
                        </div>
                        
                        <!-- Animation Library Card -->
                        <div class="animation-card library-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <span class="card-icon">📚</span>
                                    <h4>Animation Library</h4>
                                </div>
                            </div>
                            <div class="card-content">
                                <div class="library-save">
                                    <div class="save-input-group">
                                        <input id="anim-name" placeholder="Enter animation name..." class="animation-input">
                                        <button class="action-btn primary" id="anim-save" title="Save current animation" disabled>
                                            <span class="btn-icon">💾</span>
                                            Save
                                        </button>
                                    </div>
                                </div>
                                
                                <div class="library-load">
                                    <label class="setting-label">Saved Animations</label>
                                    <div class="custom-select-wrapper">
                                        <select id="anim-list" class="custom-select">
                                            <option value="">(No saved animations)</option>
                                        </select>
                                    </div>
                                    
                                    <div class="library-actions">
                                        <button class="action-btn secondary" id="anim-load" disabled title="Load Selected Animation">
                                            <span class="btn-icon">📂</span>
                                            Load
                                        </button>
                                        <button class="action-btn neutral" id="anim-rename" disabled title="Rename Animation">
                                            <span class="btn-icon">✏️</span>
                                            Rename
                                        </button>
                                        <button class="action-btn danger" id="anim-delete" disabled title="Delete Animation">
                                            <span class="btn-icon">🗑️</span>
                                            Delete
                                        </button>
                                        <button class="action-btn refresh" id="anim-refresh" title="Refresh Library">
                                            <span class="btn-icon">🔄</span>
                                            Refresh
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                <!-- Configuration Tab Content -->
                <div class="tab-content" id="config-tab-content" style="display: none;">
                    
                    <div class="config-controls">
                        
                        <!-- Export Configuration Card -->
                        <div class="animation-card export-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <span class="card-icon">📤</span>
                                    <h4>Export Configuration</h4>
                                </div>
                            </div>
                            <div class="card-content">
                                <p style="margin-bottom: 16px; color: #9CA3AF; font-size: 13px;">
                                    Export current camera, lighting, and animation settings as JSON configuration file for production use.
                                </p>
                                
                                <div class="export-actions">
                                    <button class="action-btn primary" id="config-export" title="Export current configuration as JSON">
                                        <span class="btn-icon">💾</span>
                                        Export Configuration
                                    </button>
                                    <button class="action-btn secondary" id="config-preview" title="Preview configuration JSON">
                                        <span class="btn-icon">👁️</span>
                                        Preview JSON
                                    </button>
                                </div>
                                
                                <!-- Configuration Preview Area -->
                                <div class="config-preview" id="config-preview-area" style="display: none;">
                                    <label class="setting-label">Configuration JSON Preview</label>
                                    <pre id="config-json-display" style="background: rgba(0, 0, 0, 0.4); padding: 16px; border-radius: 8px; font-size: 11px; color: #E5E7EB; overflow-x: auto; white-space: pre-wrap; word-break: break-all; max-height: 300px; overflow-y: auto; border: 1px solid rgba(75, 85, 99, 0.3);"></pre>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Import Configuration Card -->
                        <div class="animation-card import-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <span class="card-icon">📥</span>
                                    <h4>Import Configuration</h4>
                                </div>
                            </div>
                            <div class="card-content">
                                <p style="margin-bottom: 16px; color: #9CA3AF; font-size: 13px;">
                                    Load previously saved configuration to restore camera, lighting, and animation settings.
                                </p>
                                
                                <div class="import-actions">
                                    <div class="file-input-wrapper" style="margin-bottom: 12px;">
                                        <input type="file" id="config-import-file" accept=".json" style="display: none;">
                                        <button class="action-btn neutral" id="config-import-btn" title="Select JSON configuration file">
                                            <span class="btn-icon">📂</span>
                                            Select File
                                        </button>
                                        <span id="config-file-name" style="margin-left: 12px; font-size: 12px; color: #9CA3AF;"></span>
                                    </div>
                                    
                                    <button class="action-btn secondary" id="config-load" title="Load selected configuration" disabled>
                                        <span class="btn-icon">⚡</span>
                                        Load Configuration
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Push to Production Card -->
                        <div class="animation-card push-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <span class="card-icon">🚀</span>
                                    <h4>Push to Production</h4>
                                </div>
                            </div>
                            <div class="card-content">
                                <p style="margin-bottom: 16px; color: #9CA3AF; font-size: 13px;">
                                    Push current configuration to GitHub repository for automatic deployment to Webflow production site.
                                </p>
                                
                                <div class="push-actions">
                                    <div class="commit-message-wrapper" style="margin-bottom: 12px;">
                                        <label class="setting-label">Commit Message</label>
                                        <input id="commit-message" placeholder="Update 3D configuration..." class="animation-input" value="Update 3D configuration from test interface">
                                    </div>
                                    
                                    <button class="action-btn primary" id="config-push" title="Push configuration to GitHub and deploy to production">
                                        <span class="btn-icon">🌐</span>
                                        Push to Webflow
                                    </button>
                                </div>
                                
                                <div class="push-status" id="push-status" style="margin-top: 12px; font-size: 12px; color: #9CA3AF; display: none;">
                                    Ready to push configuration
                                </div>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
            </div>
        </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        let scene, camera, renderer, controls, currentModel;
        let ambientLight, warmHemisphereLight, directionalLight, fillLight; // Global light references
        let loadingStartTime = 0;
        let performanceMonitor = {
            frameCount: 0,
            lastTime: 0,
            fps: 0
        };
        
        // =============================
        // 🎬 Animation Helper (Phase 2 & 3): Includes Tasks 2.1 - 2.5 & 3.1 - 3.5
        // =============================
        const animationHelper = {
            keyframes: [], // { id, position: Vector3, target: Vector3, timestamp }
            durations: [], // ms per segment (between i and i+1)
            easing: 'linear',
            playing: false,
            paused: false,
            startTime: 0,
            elapsedBeforePause: 0,
            rafId: null
        };

        const EASING = {
            linear: t => t,
            easeIn: t => t * t,
            easeOut: t => 1 - (1 - t) * (1 - t),
            easeInOut: t => t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t),
            bounce: t => {
                if (t < 1/2.75) return 7.5625 * t * t;
                if (t < 2/2.75) return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
                if (t < 2.5/2.75) return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
                return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
            }
        };

        // Welcome animation - runs automatically when first model loads
        let hasPlayedWelcomeAnimation = false;
        function playWelcomeAnimation() {
            if (hasPlayedWelcomeAnimation || !camera || !controls) return;
            
            hasPlayedWelcomeAnimation = true;
            console.log('🎬 Starting welcome animation...');
            
            // Start position - only set this for the welcome animation
            const startPos = new THREE.Vector3(43.8, 38.1, 63.7);
            const startTarget = new THREE.Vector3(3.5, -35.4, -14.7);
            
            // End position  
            const endPos = new THREE.Vector3(15.2, 31.7, 17.3);
            const endTarget = new THREE.Vector3(-0.8, -33.2, -15.3);
            
            // Set the starting position immediately before animation (no jump because it's instant)
            camera.position.copy(startPos);
            controls.target.copy(startTarget);
            controls.update();
            
            // Save this animation as "intro" for replay
            saveIntroAnimation(startPos, startTarget, endPos, endTarget);
            
            // Animate to end position over 1.7 seconds
            const duration = 1700; // 1.7 seconds
            const startTime = performance.now();
            
            const animate = () => {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = EASING.easeInOut(progress);
                
                // Interpolate position
                camera.position.lerpVectors(startPos, endPos, easedProgress);
                
                // Interpolate target
                controls.target.lerpVectors(startTarget, endTarget, easedProgress);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    console.log('✅ Welcome animation complete');
                    // After animation completes, reset to a neutral position for subsequent model loads
                    // Don't modify camera position - let subsequent loads use their own positioning
                }
            };
            
            requestAnimationFrame(animate);
        }
        
        // Save intro animation to animation helper library
        function saveIntroAnimation(startPos, startTarget, endPos, endTarget) {
            const introAnimation = {
                keyframes: [
                    {
                        position: { x: startPos.x, y: startPos.y, z: startPos.z },
                        target: { x: startTarget.x, y: startTarget.y, z: startTarget.z },
                        timestamp: 0
                    },
                    {
                        position: { x: endPos.x, y: endPos.y, z: endPos.z },
                        target: { x: endTarget.x, y: endTarget.y, z: endTarget.z },
                        timestamp: 1700
                    }
                ],
                durations: [1700],
                easing: 'easeInOut',
                savedAt: Date.now()
            };
            
            try {
                const lib = JSON.parse(localStorage.getItem('animationHelperLibrary_v1') || '{}');
                lib['intro'] = introAnimation;
                localStorage.setItem('animationHelperLibrary_v1', JSON.stringify(lib));
                console.log('💾 Intro animation saved for replay');
                
                // Refresh the dropdown and select "intro" by default if the animation helper is initialized
                setTimeout(() => {
                    if (typeof populateSavedAnimations === 'function') {
                        populateSavedAnimations('intro');
                    }
                }, 100);
            } catch (e) {
                console.warn('Failed to save intro animation:', e);
            }
        }
        
        // Function to replay the intro animation
        window.replayIntro = function() {
            if (!camera || !controls) return;
            
            const startPos = new THREE.Vector3(43.8, 38.1, 63.7);
            const startTarget = new THREE.Vector3(3.5, -35.4, -14.7);
            const endPos = new THREE.Vector3(15.2, 31.7, 17.3);
            const endTarget = new THREE.Vector3(-0.8, -33.2, -15.3);
            
            // Set starting position
            camera.position.copy(startPos);
            controls.target.copy(startTarget);
            controls.update();
            
            console.log('🎬 Replaying intro animation...');
            
            // Animate to end position
            const duration = 1700;
            const startTime = performance.now();
            
            const animate = () => {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = EASING.easeInOut(progress);
                
                camera.position.lerpVectors(startPos, endPos, easedProgress);
                controls.target.lerpVectors(startTarget, endTarget, easedProgress);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    console.log('✅ Intro animation replay complete');
                }
            };
            
            requestAnimationFrame(animate);
        };
        
        // Comparison mode variables
        let isComparisonMode = false;
        let modelA = null;
        let modelB = null;
        let currentOpacity = 50;
        
        // Dynamic model discovery
        let MODEL_URLS = {};
        let availableModels = [];
        
        // ========================================
        // 📝 AUTOMATIC MODEL DETECTION:
        // The interface will automatically detect ALL .glb and .gltf files
        // in your public folder and display them with their exact filenames.
        // No need to list them here - just drop files into public/ folder!
        // ========================================
        const USER_MODELS = [
            // Optional: Add specific filenames here if auto-detection fails
        ];
        
        // Keep track of preferred model for auto-loading
        // Per request: always auto-load the smallest model first.
        let smallestModelKey = null;

        // Heuristic size ranking based on filename
        function sizeRankForName(name) {
            const n = (name || '').toLowerCase();
            if (n.includes('webp15')) return 1; // smallest
            if (n.includes('webp25')) return 2;
            if (n.includes('webp')) return 3;
            if (n.includes('with-textures') || n.includes('textures')) return 5; // likely largest
            return 4; // default in between
        }
        
        // Auto-discover models in public folder
        async function discoverModels() {
            try {
                updateModelStatus('✨ Loading available models...');
                
                // Direct list of your 4 models in the public folder
                const modelFiles = [
                    './public/Goetheviertel_250812_with-textures.glb',
                    './public/Goetheviertel_250812_with-textures_webp.glb',
                    './public/Goetheviertel_250812_with-textures_webp15.glb',
                    './public/Goetheviertel_250812_with-textures_webp25.glb'
                ];
                
                console.log('✅ Loading models:', modelFiles);
                
                // No need for separate GitHub models - using direct paths above
                
                // Create model entries
                availableModels = [];
                MODEL_URLS = {};
                
                // Add local files (preserve exact original filenames)
                modelFiles.forEach(filePath => {
                    const fileName = filePath.split('/').pop();
                    const displayName = fileName; // Use exact original filename as display name
                    
                    // Create unique key from filename but keep original name for display
                    const key = fileName.replace(/\.(gltf|glb)$/i, '').toLowerCase().replace(/[^a-z0-9]/g, '_');
                    
                    // Smart ordering based on file modification time or filename numbers
                    let priority = 0;
                    const numbers = fileName.match(/\d+/g);
                    if (numbers) {
                        // Use last number in filename as priority (higher = newer)
                        priority = parseInt(numbers[numbers.length - 1]) || 0;
                    }
                    
                    // Special handling for webp quality files (webp15, webp25, etc.)
                    const webpMatch = fileName.match(/webp(\d+)/i);
                    if (webpMatch) {
                        priority = parseInt(webpMatch[1]) + 1000; // Give webp files higher priority
                    }
                    
                    // Special handling for date-based naming
                    const dateMatch = fileName.match(/(\d{6})/); // YYMMDD format
                    if (dateMatch) {
                        priority = parseInt(dateMatch[1]) + 10000; // Date-based files get highest priority
                    }
                    
                    const modelInfo = {
                        key: key,
                        name: displayName, // Original filename without any modification
                        url: filePath,
                        type: filePath.endsWith('.glb') ? 'GLB' : 'GLTF',
                        source: 'Local',
                        priority: priority,
                        originalFileName: fileName
                    };
                    
                    availableModels.push(modelInfo);
                    MODEL_URLS[key] = filePath;
                });
                
                // Determine the smallest model by heuristic
                const localModels = availableModels.filter(m => m.source === 'Local');
                if (localModels.length > 0) {
                    const smallestLocal = localModels.reduce((smallest, current) => {
                        const sRank = sizeRankForName(smallest.name);
                        const cRank = sizeRankForName(current.name);
                        if (cRank < sRank) return current;
                        if (cRank === sRank) {
                            // tie-breaker: prefer GLB over GLTF for speed, then by filename lexicographically
                            const sType = smallest.type === 'GLB' ? 0 : 1;
                            const cType = current.type === 'GLB' ? 0 : 1;
                            if (cType < sType) return current;
                            if (cType === sType && (current.name < smallest.name)) return current;
                        }
                        return smallest;
                    });
                    smallestModelKey = smallestLocal.key;
                    console.log('🎯 Smallest local model detected:', smallestLocal.name, 'sizeRank:', sizeRankForName(smallestLocal.name));
                }
                
                // Sort models by priority (newest first)
                availableModels.sort((a, b) => (b.priority || 0) - (a.priority || 0));
                
                // Update UI
                populateModelSelectors();
                
                const modelCount = availableModels.length;
                
                updateModelStatus(`✅ Found ${modelCount} models! 🎮 Ready to test.`);
                
                // Auto-load the smallest model if available
                if (smallestModelKey && availableModels.find(m => m.key === smallestModelKey)) {
                    const smallestModel = availableModels.find(m => m.key === smallestModelKey);
                    updateModelStatus(`🚀 Auto-loading smallest model: ${smallestModel.name}...`);
                    setTimeout(() => {
                        loadModel(smallestModelKey, smallestModel.name);
                    }, 1500);
                }
                
                console.log('Discovered models:', availableModels);
                
            } catch (error) {
                console.warn('Could not auto-discover models:', error);
                // Fallback to hardcoded models
                await loadFallbackModels();
            }
        }
        
        // Fallback to hardcoded models if discovery fails
        async function loadFallbackModels() {
            availableModels = [
                { key: 'goetheviertel_textures', name: 'Goetheviertel With Textures', url: '/Goetheviertel_250812_with-textures.glb', type: 'GLB', source: 'Local' },
                { key: 'goetheviertel_webp', name: 'Goetheviertel WebP', url: '/Goetheviertel_250812_with-textures_webp.glb', type: 'GLB', source: 'Local' },
                { key: 'goetheviertel_webp15', name: 'Goetheviertel WebP15', url: '/Goetheviertel_250812_with-textures_webp15.glb', type: 'GLB', source: 'Local' },
                { key: 'goetheviertel_webp25', name: 'Goetheviertel WebP25', url: '/Goetheviertel_250812_with-textures_webp25.glb', type: 'GLB', source: 'Local' }
            ];
            
            MODEL_URLS = {};
            availableModels.forEach(model => {
                MODEL_URLS[model.key] = model.url;
            });
            
            populateModelSelectors();
            updateModelStatus('✅ Loaded fallback model list.<br/>🎮 Ready for testing!');

            // Auto-load the smallest model in fallback as well
            const smallest = availableModels.reduce((s, c) => {
                const sRank = sizeRankForName(s.name);
                const cRank = sizeRankForName(c.name);
                return (cRank < sRank) ? c : s;
            }, availableModels[0]);
            smallestModelKey = smallest.key;
            updateModelStatus(`🚀 Auto-loading smallest model: ${smallest.name}...`);
            setTimeout(() => {
                loadModel(smallestModelKey, smallest.name);
            }, 1200);
        }
        
        // Populate model selector dropdowns with separated groups
        function populateModelSelectors() {
            const selectA = document.getElementById('model-a-select');
            const selectB = document.getElementById('model-b-select');
            
            // Clear existing options
            selectA.innerHTML = '';
            selectB.innerHTML = '';
            
            // Separate models by source
            const localModels = availableModels.filter(m => m.source === 'Local');
            const githubModels = availableModels.filter(m => m.source === 'GitHub');
            
            // Helper function to add model group
            function addModelGroup(select, models, groupName) {
                if (models.length === 0) return;
                
                // Add group label
                const optgroup = document.createElement('optgroup');
                optgroup.label = groupName;
                
                models.forEach(model => {
                    const iconMap = {
                        'GLTF': '📄',
                        'GLB': '📦'
                    };
                    
                    const icon = iconMap[model.type] || '📄';
                    const displayText = `${icon} ${model.name}`;
                    
                    const option = document.createElement('option');
                    option.value = model.key;
                    option.textContent = displayText;
                    optgroup.appendChild(option);
                });
                
                select.appendChild(optgroup);
            }
            
            // Add groups to both selectors
            addModelGroup(selectA, localModels, '🏠 Local Models');
            addModelGroup(selectA, githubModels, '🌐 GitHub Models');
            
            addModelGroup(selectB, localModels, '🏠 Local Models');
            addModelGroup(selectB, githubModels, '🌐 GitHub Models');
            
            // Set default selections if models exist
            if (availableModels.length >= 2) {
                selectA.value = availableModels[0].key;
                selectB.value = availableModels[1].key;
            }
            
            // Add auto-loading event listeners for comparison mode
            selectA.addEventListener('change', () => {
                if (isComparisonMode) {
                    loadBothModels();
                }
            });
            
            selectB.addEventListener('change', () => {
                if (isComparisonMode) {
                    loadBothModels();
                }
            });
            
            // Update single model controls
            updateSingleModelControls();
        }
        
        // Update single model control buttons with two-column layout
        function updateSingleModelControls() {
            const container = document.getElementById('single-model-controls');
            container.innerHTML = '';
            
            // Separate models by source
            const localModels = availableModels.filter(m => m.source === 'Local');
            const githubModels = availableModels.filter(m => m.source === 'GitHub');
            
            // Create grid container
            const gridContainer = document.createElement('div');
            gridContainer.className = 'models-grid';
            
            // Helper function to create model group
            function createModelGroup(models, groupName) {
                const group = document.createElement('div');
                group.className = 'model-group';
                
                if (models.length === 0) return group;
                
                // Add group header
                const groupHeader = document.createElement('div');
                groupHeader.className = 'model-group-label';
                groupHeader.textContent = groupName;
                group.appendChild(groupHeader);
                
                // Add buttons for models
                models.forEach(model => {
                    const button = document.createElement('button');
                    button.className = 'btn';
                    button.onclick = () => loadModel(model.key, model.name);
                    
                    const iconMap = {
                        'GLTF': '📄',
                        'GLB': '📦'
                    };
                    
                    const icon = iconMap[model.type] || '📄';
                    // Use original filename without truncation for better readability
                    button.innerHTML = `${icon} ${model.name}`;
                    button.title = model.name; // Add tooltip for full name
                    group.appendChild(button);
                });
                
                return group;
            }
            
            // Create both groups
            const localGroup = createModelGroup(localModels, '🏠 Local Models');
            const githubGroup = createModelGroup(githubModels, '🌐 GitHub Models');
            
            // Add groups to grid
            gridContainer.appendChild(localGroup);
            gridContainer.appendChild(githubGroup);
            
            container.appendChild(gridContainer);
        }

        function updateModelStatus(msg, isError = false) {
            const statusEl = document.getElementById('model-status');
            // Reset to default color (no classes)
            statusEl.classList.remove('status-success', 'status-error', 'status-loading');
            statusEl.style.color = '';

            // Only success (first line) should be green
            if (msg && msg.includes('✅')) {
                const parts = String(msg).split('<br/>');
                const first = parts.shift();
                const rebuilt = [`<span class="status-success">${first}</span>`, ...parts].join('<br/>');
                statusEl.innerHTML = rebuilt;
            } else {
                statusEl.innerHTML = msg;
            }

            console.log(String(msg).replace(/<br\/>/g, '\n').replace(/<[^>]*>/g, ''));
        }
        
        // Mode switching functions
        function setMode(mode) {
            isComparisonMode = (mode === 'comparison');
            
            // Update UI
            document.getElementById('single-mode-btn').classList.toggle('active', !isComparisonMode);
            document.getElementById('comparison-mode-btn').classList.toggle('active', isComparisonMode);
            document.getElementById('comparison-panel').style.display = isComparisonMode ? 'block' : 'none';
            document.getElementById('single-model-controls').style.display = isComparisonMode ? 'none' : 'block';
            
            // Clear existing models when switching modes
            clearAllModels();
            
            if (isComparisonMode) {
                updateModelStatus('🔄 Comparison mode activated!<br/>Select two models to compare quality differences.');
            } else {
                updateModelStatus('🎯 Single model mode activated!<br/>Click a button to load a model.');
            }
        }
        
        function clearAllModels() {
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            if (modelA) {
                scene.remove(modelA);
                modelA = null;
            }
            if (modelB) {
                scene.remove(modelB);
                modelB = null;
            }
        }
        
        // Dual model loading function
        async function loadBothModels() {
            const modelAKey = document.getElementById('model-a-select').value;
            const modelBKey = document.getElementById('model-b-select').value;
            
            if (modelAKey === modelBKey) {
                updateModelStatus('⚠️ Please select different models for comparison!', true);
                return;
            }
            
            updateModelStatus('🔄 Loading both models for comparison...');
            clearAllModels();
            
            try {
                // Load both models in parallel
                const [modelAResult, modelBResult] = await Promise.all([
                    loadModelForComparison(modelAKey, 'Model A'),
                    loadModelForComparison(modelBKey, 'Model B')
                ]);
                
                modelA = modelAResult.model;
                modelB = modelBResult.model;
                
                // Position and scale models identically
                setupDualModels();
                
                // Apply initial opacity
                updateOpacity(currentOpacity);
                
                updateModelStatus(`
                    ✅ Comparison loaded successfully!<br/>
                    📦 Model A: ${modelAResult.meshCount} meshes | ${modelAResult.loadTime}s<br/>
                    📦 Model B: ${modelBResult.meshCount} meshes | ${modelBResult.loadTime}s<br/>
                    🎛️ Use the slider to compare quality differences!
                `);
                
            } catch (error) {
                console.error('Dual model loading error:', error);
                updateModelStatus(`❌ Failed to load models for comparison:<br/>${error.message}`, true);
            }
        }
        
        // Load single model for comparison
        function loadModelForComparison(modelKey, displayName) {
            return new Promise((resolve, reject) => {
                const url = MODEL_URLS[modelKey];
                if (!url) {
                    reject(new Error(`Unknown model: ${modelKey}`));
                    return;
                }
                
                const loader = new GLTFLoader();
                const dracoLoader = new DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                dracoLoader.preload();
                loader.setDRACOLoader(dracoLoader);
                
                const startTime = performance.now();
                
                loader.load(
                    url,
                    (gltf) => {
                        const loadTime = ((performance.now() - startTime) / 1000).toFixed(2);
                        const model = gltf.scene;
                        
                        // Count meshes
                        let meshCount = 0;
                        model.traverse((child) => {
                            if (child.isMesh) {
                                meshCount++;
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                if (child.material) {
                                    child.material.needsUpdate = true;
                                    if (child.material.map && renderer.capabilities) {
                                        child.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
                                    }
                                }
                            }
                        });
                        
                        resolve({ model, meshCount, loadTime });
                    },
                    undefined,
                    (error) => reject(error)
                );
            });
        }
        
        // Setup dual models with identical positioning
        function setupDualModels() {
            if (!modelA || !modelB) return;
            
            // Calculate combined bounding box for consistent scaling
            const boxA = new THREE.Box3().setFromObject(modelA);
            const boxB = new THREE.Box3().setFromObject(modelB);
            
            const sizeA = boxA.getSize(new THREE.Vector3());
            const sizeB = boxB.getSize(new THREE.Vector3());
            
            // Use the larger model as reference for scaling
            const maxSizeA = Math.max(sizeA.x, sizeA.y, sizeA.z);
            const maxSizeB = Math.max(sizeB.x, sizeB.y, sizeB.z);
            const referenceSize = Math.max(maxSizeA, maxSizeB);
            const scale = 100 / referenceSize;
            
            // Scale both models identically
            modelA.scale.setScalar(scale);
            modelB.scale.setScalar(scale);
            
            // Center both models at the same position
            const centerA = boxA.getCenter(new THREE.Vector3());
            const centerB = boxB.getCenter(new THREE.Vector3());
            
            modelA.position.set(-centerA.x * scale, -centerA.y * scale, -centerA.z * scale);
            modelB.position.set(-centerB.x * scale, -centerB.y * scale, -centerB.z * scale);
            
            // Add both models to scene
            scene.add(modelA);
            scene.add(modelB);
            
            // Position camera for good view
            const idealDistance = referenceSize * scale * 1.5;
            camera.position.set(idealDistance * 0.5, idealDistance * 0.3, idealDistance);
            camera.lookAt(0, 0, 0);
            controls.update();
        }
        
        // Opacity control functions
        function updateOpacity(value) {
            currentOpacity = parseInt(value);
            const opacityA = (100 - currentOpacity) / 100;
            const opacityB = currentOpacity / 100;
            
            // Update display
            document.getElementById('opacity-display').textContent = `${Math.round(opacityA * 100)}%`;
            document.getElementById('opacity-display-b').textContent = `${Math.round(opacityB * 100)}%`;
            
            // Apply opacity to models
            if (modelA) {
                modelA.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.transparent = true;
                        child.material.opacity = opacityA;
                        child.material.needsUpdate = true;
                    }
                });
            }
            
            if (modelB) {
                modelB.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.transparent = true;
                        child.material.opacity = opacityB;
                        child.material.needsUpdate = true;
                    }
                });
            }
        }
        
        // Swap models A and B
        function swapModels() {
            const selectA = document.getElementById('model-a-select');
            const selectB = document.getElementById('model-b-select');
            
            const tempValue = selectA.value;
            selectA.value = selectB.value;
            selectB.value = tempValue;
            
            updateModelStatus('🔄 Models swapped! Click "Load Both" to apply changes.');
        }
        
        // Load preset comparison pairs
        function loadPreset(presetName) {
            const selectA = document.getElementById('model-a-select');
            const selectB = document.getElementById('model-b-select');
            
            switch (presetName) {
                case 'texture-comparison':
                    // Find best available models for texture comparison
                    if (availableModels.find(m => m.key === 'goetheviertel_textures') && 
                        availableModels.find(m => m.key === 'goetheviertel_webp')) {
                        selectA.value = 'goetheviertel_textures';
                        selectB.value = 'goetheviertel_webp';
                        updateModelStatus('🎨 Texture comparison preset loaded!<br/>Full Textures vs WebP Compressed');
                    } else {
                        updateModelStatus('⚠️ Texture comparison models not available', true);
                    }
                    break;
                case 'format-comparison':
                    // Compare WebP compression levels
                    if (availableModels.find(m => m.key === 'goetheviertel_webp15') && 
                        availableModels.find(m => m.key === 'goetheviertel_webp25')) {
                        selectA.value = 'goetheviertel_webp15';
                        selectB.value = 'goetheviertel_webp25';
                        updateModelStatus('🖼️ WebP comparison preset loaded!<br/>15% vs 25% Quality');
                    } else {
                        updateModelStatus('⚠️ WebP comparison models not available', true);
                    }
                    break;
                default:
                    updateModelStatus('⚠️ Unknown preset: ' + presetName, true);
            }
        }
        
        function updateCameraInfo() {
            if (!camera || !controls) return;
            
            const pos = camera.position;
            const target = controls.target;
            const distance = pos.distanceTo(target);
            
            // Calculate rotation in degrees
            const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
            const rotX = THREE.MathUtils.radToDeg(euler.x);
            const rotY = THREE.MathUtils.radToDeg(euler.y);
            
            document.getElementById('camera-position').textContent = 
                `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
            document.getElementById('camera-target').textContent = 
                `${target.x.toFixed(1)}, ${target.y.toFixed(1)}, ${target.z.toFixed(1)}`;
            document.getElementById('camera-distance').textContent = distance.toFixed(1);
            document.getElementById('camera-rotation').textContent = 
                `${rotX.toFixed(1)}°, ${rotY.toFixed(1)}°`;
        }
        
        function updatePerformanceInfo() {
            if (!renderer) return;
            
            // Calculate FPS
            performanceMonitor.frameCount++;
            const currentTime = performance.now();
            if (currentTime - performanceMonitor.lastTime >= 1000) {
                performanceMonitor.fps = Math.round(performanceMonitor.frameCount * 1000 / (currentTime - performanceMonitor.lastTime));
                performanceMonitor.frameCount = 0;
                performanceMonitor.lastTime = currentTime;
            }
            
            const info = renderer.info;
            document.getElementById('fps-counter').textContent = performanceMonitor.fps;
            document.getElementById('triangle-count').textContent = info.render.triangles.toLocaleString();
            document.getElementById('draw-calls').textContent = info.render.calls;
            document.getElementById('memory-usage').textContent = 
                `${info.memory.geometries}G / ${info.memory.textures}T`;
        }
        
        function loadModel(type, displayName) {
            const url = MODEL_URLS[type];
            if (!url) {
                updateModelStatus(`❌ Unknown model type: ${type}`, true);
                return;
            }
            
            loadingStartTime = performance.now();
            updateModelStatus(`🔄 Loading ${displayName}...<br/>⏱️ Started at ${new Date().toLocaleTimeString()}`);
            
            // Remove existing model
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            
            const loader = new GLTFLoader();
            
            // Set up DRACO loader
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
            dracoLoader.preload();
            loader.setDRACOLoader(dracoLoader);
            
            let lastProgressTime = loadingStartTime;
            
            loader.load(
                url,
                (gltf) => {
                    const loadTime = performance.now() - loadingStartTime;
                    
                    currentModel = gltf.scene;
                    
                    // Scale and center the model
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const size = box.getSize(new THREE.Vector3());
                    const maxSize = Math.max(size.x, size.y, size.z);
                    const scale = 100 / maxSize;
                    currentModel.scale.setScalar(scale);
                    
                    const center = box.getCenter(new THREE.Vector3());
                    currentModel.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
                    
                    // Count meshes and materials
                    let meshCount = 0;
                    let materialCount = 0;
                    let textureCount = 0;
                    const materials = new Set();
                    
                    currentModel.traverse((child) => {
                        if (child.isMesh) {
                            meshCount++;
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            if (child.material) {
                                materials.add(child.material.uuid);
                                if (child.material.map) textureCount++;
                                if (child.material.normalMap) textureCount++;
                                if (child.material.roughnessMap) textureCount++;
                                if (child.material.metalnessMap) textureCount++;
                                
                                child.material.needsUpdate = true;
                                if (child.material.map && renderer.capabilities) {
                                    child.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
                                }
                            }
                        }
                    });
                    
                    materialCount = materials.size;
                    scene.add(currentModel);
                    
                    // For first model, preserve camera (will be handled by welcome animation)
                    // For subsequent models, reset to default position
                    if (hasPlayedWelcomeAnimation) {
                        // Reset camera to default position for all models after the first one
                        camera.position.set(-23.8, 69.2, 89.3);
                        controls.target.set(3.5, -35.4, -14.7);
                        camera.lookAt(3.5, -35.4, -14.7);
                        controls.update();
                    } else {
                        // First model - just update controls, welcome animation will handle positioning
                        controls.update();
                    }
                    const currentDistance = camera.position.distanceTo(controls.target);
                    
                    // Calculate file size estimate
                    const fileSize = gltf.parser ? 
                        (gltf.parser.json.buffers ? 
                            gltf.parser.json.buffers.reduce((sum, buf) => sum + (buf.byteLength || 0), 0) : 0) : 0;
                    
                    updateModelStatus(`
                        ✅ ${displayName} loaded successfully!<br/>
                        ⏱️ <strong>Load time: ${(loadTime / 1000).toFixed(2)}s</strong><br/>
                        📦 Meshes: ${meshCount} | Materials: ${materialCount}<br/>
                        🎨 Textures: ${textureCount} | Scale: ${scale.toFixed(2)}x<br/>
                        📏 Size: ${size.x.toFixed(0)} × ${size.y.toFixed(0)} × ${size.z.toFixed(0)}<br/>
                        💾 Est. size: ${(fileSize / 1024 / 1024).toFixed(1)}MB<br/>
                        📍 Camera distance ${currentDistance.toFixed(1)} (preserved)
                    `);
                    
                    // Trigger welcome animation for first model load
                    setTimeout(() => playWelcomeAnimation(), 500);
                    
                    window.map3dScene = { scene, camera, renderer, controls, model: currentModel };
                },
                (progress) => {
                    const now = performance.now();
                    const currentLoadTime = (now - loadingStartTime) / 1000;
                    
                    if (progress.total > 0) {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        const loaded = (progress.loaded / 1024 / 1024).toFixed(1);
                        const total = (progress.total / 1024 / 1024).toFixed(1);
                        const speed = (progress.loaded / 1024 / (now - loadingStartTime)) * 1000; // KB/s
                        
                        updateModelStatus(`
                            📥 Loading ${displayName}: ${percent}%<br/>
                            📊 ${loaded}MB / ${total}MB<br/>
                            🚀 Speed: ${speed.toFixed(0)} KB/s<br/>
                            ⏱️ Elapsed: ${currentLoadTime.toFixed(1)}s
                        `);
                    } else {
                        updateModelStatus(`
                            📥 Loading ${displayName}...<br/>
                            📊 ${(progress.loaded / 1024 / 1024).toFixed(1)}MB loaded<br/>
                            ⏱️ Elapsed: ${currentLoadTime.toFixed(1)}s
                        `);
                    }
                },
                (error) => {
                    const failTime = (performance.now() - loadingStartTime) / 1000;
                    console.error(`${displayName} loading error:`, error);
                    updateModelStatus(`
                        ❌ Failed to load ${displayName}<br/>
                        💥 Error: ${error.message}<br/>
                        ⏱️ Failed after: ${failTime.toFixed(1)}s<br/>
                        🌐 URL: ${url.substring(0, 50)}...
                    `, true);
                }
            );
        }
        
        // =============================
        // 💡 Lighting Controls System
        // =============================
        
        // Tab switching
        function switchControlsTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Show/hide tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(tabName + '-tab-content').style.display = 'block';
            
            // Initialize animation helper UI when animation tab is shown
            if (tabName === 'animation') {
                setTimeout(() => {
                    initAnimationHelperUI();
                }, 50);
            }
        }
        
        // Update warm hemisphere light
        function updateWarmLight() {
            if (!warmHemisphereLight) return;
            
            const enabledEl = document.getElementById('warm-enabled');
            const intensityEl = document.getElementById('warm-intensity');
            const skyColorEl = document.getElementById('warm-sky-color');
            const groundColorEl = document.getElementById('warm-ground-color');
            const valueDisplayEl = document.getElementById('warm-intensity-value');
            
            if (!enabledEl || !intensityEl || !skyColorEl || !groundColorEl) return;
            
            const enabled = enabledEl.checked;
            const intensity = parseFloat(intensityEl.value);
            const skyColor = skyColorEl.value;
            const groundColor = groundColorEl.value;
            
            warmHemisphereLight.intensity = enabled ? intensity : 0;
            warmHemisphereLight.color.setHex(parseInt(skyColor.replace('#', ''), 16));
            warmHemisphereLight.groundColor.setHex(parseInt(groundColor.replace('#', ''), 16));
            
            if (valueDisplayEl) valueDisplayEl.textContent = intensity.toFixed(1);
            
            // Update card visual state
            const card = document.querySelector('.warm-light');
            if (card) {
                if (enabled) {
                    card.classList.remove('disabled');
                } else {
                    card.classList.add('disabled');
                }
            }
        }
        
        // Update main directional light
        function updateMainLight() {
            if (!directionalLight) return;
            
            const enabledEl = document.getElementById('main-enabled');
            const intensityEl = document.getElementById('main-intensity');
            const valueDisplayEl = document.getElementById('main-intensity-value');
            
            if (!enabledEl || !intensityEl) return;
            
            const enabled = enabledEl.checked;
            const intensity = parseFloat(intensityEl.value);
            
            directionalLight.intensity = enabled ? intensity : 0;
            
            if (valueDisplayEl) valueDisplayEl.textContent = intensity.toFixed(1);
            
            // Update card visual state
            const card = document.querySelector('.main-light');
            if (card) {
                if (enabled) {
                    card.classList.remove('disabled');
                } else {
                    card.classList.add('disabled');
                }
            }
        }
        
        // Toggle shadows
        function updateShadows() {
            if (!directionalLight || !renderer) return;
            
            const enabled = document.getElementById('shadows-enabled').checked;
            directionalLight.castShadow = enabled;
            
            // Also update shadow settings if enabling
            if (enabled) {
                directionalLight.shadow.camera.near = 1;
                directionalLight.shadow.camera.far = 1000;
                directionalLight.shadow.camera.left = -500;
                directionalLight.shadow.camera.right = 500;
                directionalLight.shadow.camera.top = 500;
                directionalLight.shadow.camera.bottom = -500;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.bias = -0.00001;
                directionalLight.shadow.normalBias = 0.02;
                directionalLight.shadow.radius = 4;
            }
        }
        
        // Update fill light
        function updateFillLight() {
            if (!fillLight) return;
            
            const enabledEl = document.getElementById('fill-enabled');
            const intensityEl = document.getElementById('fill-intensity');
            const colorEl = document.getElementById('fill-color');
            const valueDisplayEl = document.getElementById('fill-intensity-value');
            
            if (!enabledEl || !intensityEl || !colorEl) return;
            
            const enabled = enabledEl.checked;
            const intensity = parseFloat(intensityEl.value);
            const color = colorEl.value;
            
            fillLight.intensity = enabled ? intensity : 0;
            fillLight.color.setHex(parseInt(color.replace('#', ''), 16));
            
            if (valueDisplayEl) valueDisplayEl.textContent = intensity.toFixed(1);
            
            // Update card visual state
            const card = document.querySelector('.fill-light');
            if (card) {
                if (enabled) {
                    card.classList.remove('disabled');
                } else {
                    card.classList.add('disabled');
                }
            }
        }
        
        // Update ambient light
        function updateAmbientLight() {
            if (!ambientLight) return;
            
            const enabledEl = document.getElementById('ambient-enabled');
            const intensityEl = document.getElementById('ambient-intensity');
            const colorEl = document.getElementById('ambient-color');
            const valueDisplayEl = document.getElementById('ambient-intensity-value');
            
            if (!enabledEl || !intensityEl) return;
            
            const enabled = enabledEl.checked;
            const intensity = parseFloat(intensityEl.value);
            
            ambientLight.intensity = enabled ? intensity : 0;
            if (colorEl) {
                const color = colorEl.value;
                ambientLight.color.setHex(parseInt(color.replace('#', ''), 16));
            }
            
            if (valueDisplayEl) valueDisplayEl.textContent = intensity.toFixed(1);
            
            // Update card visual state
            const card = document.querySelector('.ambient-light');
            if (card) {
                if (enabled) {
                    card.classList.remove('disabled');
                } else {
                    card.classList.add('disabled');
                }
            }
        }
        
        // Make functions global
        window.switchControlsTab = switchControlsTab;
        window.updateWarmLight = updateWarmLight;
        window.updateMainLight = updateMainLight;
        window.updateShadows = updateShadows;
        window.updateFillLight = updateFillLight;
        window.updateAmbientLight = updateAmbientLight;
        
        function initMap() {
            try {
                updateModelStatus('🚀 Initializing 3D environment...');
                
                // Create container
                const container = document.createElement('div');
                container.id = 'map-3d-container';
                container.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    z-index: 0; /* Raised so it can receive pointer events outside panels */
                    background: #000000;
                `;
                document.body.insertBefore(container, document.body.firstChild);
                
                // Create scene
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x87CEEB, 50, 1000);
                
                // Create camera
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
                // Start at welcome animation's starting position to avoid jump
                camera.position.set(43.8, 38.1, 63.7);
                
                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);
                
                // Add controls
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 20;
                controls.maxDistance = 800;
                controls.maxPolarAngle = Math.PI / 2.1;
                // Set initial camera target to match welcome animation start
                controls.target.set(3.5, -35.4, -14.7);
                camera.lookAt(3.5, -35.4, -14.7);
                // Persist as reset state
                if (typeof controls.saveState === 'function') controls.saveState();
                
                // Add lighting
                ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                // Super diffuse warm light source
                warmHemisphereLight = new THREE.HemisphereLight(
                    0xffd4a3, // Warm sky color (soft golden)
                    0xff8c42, // Warm ground color (warmer orange)
                    1.0       // Increased intensity for brighter effect
                );
                warmHemisphereLight.position.set(0, 50, 0);
                scene.add(warmHemisphereLight);

                directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(200, 200, 100);
                directionalLight.castShadow = false; // Disable shadows to eliminate artifacts
                scene.add(directionalLight);

                fillLight = new THREE.DirectionalLight(0x87ceeb, 0.4);
                fillLight.position.set(-100, 50, -100);
                scene.add(fillLight);
                
                // Initialize lighting controls to match UI defaults (after DOM is ready)
                setTimeout(() => {
                    updateWarmLight();
                    updateMainLight();
                    updateFillLight();
                    updateAmbientLight();
                }, 100);
                
                // Animation loop with monitoring
                function animate() {
                    requestAnimationFrame(animate);
                    
                    if (controls) controls.update();
                    if (renderer && scene && camera) renderer.render(scene, camera);
                    
                    // Update info displays
                    updateCameraInfo();
                    updatePerformanceInfo();
                }
                animate();
                
                // Handle resize
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Detect user interaction to optionally stop animation playback (robust debounce)
                let interactionTimeout = null;
                animationHelper.suppressNextInteraction = false; // ignore Play click during activation
                const canvasEl = renderer.domElement;
                let pointerActive = false; // true only while user is physically dragging
                let lastInteractionAt = 0;  // timestamp of last genuine interaction
                const markInteracting = (source) => {
                    if (animationHelper.suppressNextInteraction) return; // ignore suppressed events
                    animationHelper._userInteracting = true;
                    lastInteractionAt = performance.now();
                    if (interactionTimeout) clearTimeout(interactionTimeout);
                    interactionTimeout = setTimeout(() => { animationHelper._userInteracting = false; }, 650); // idle threshold
                };
                const pointerDownHandler = (e) => {
                    if (canvasEl.contains(e.target) || e.target === canvasEl) {
                        pointerActive = true;
                        markInteracting('pointerdown');
                    }
                };
                const pointerUpHandler = () => { pointerActive = false; };
                window.addEventListener('pointerdown', pointerDownHandler, { passive: true });
                window.addEventListener('pointerup', pointerUpHandler, { passive: true });
                window.addEventListener('pointercancel', pointerUpHandler, { passive: true });
                window.addEventListener('wheel', (e) => {
                    if (canvasEl.contains(e.target) || e.target === canvasEl) markInteracting('wheel');
                }, { passive: true });
                window.addEventListener('pointermove', (e) => {
                    if (!pointerActive) return;
                    if (canvasEl.contains(e.target) || e.target === canvasEl) markInteracting('pointermove');
                }, { passive: true });
                // Touch support
                window.addEventListener('touchstart', (e) => {
                    if ([...e.touches].some(t => true)) { // basic truthy; rely on target check of first touch
                        if (canvasEl.contains(e.target) || e.target === canvasEl) {
                            pointerActive = true;
                            markInteracting('touchstart');
                        }
                    }
                }, { passive: true });
                window.addEventListener('touchend', () => { pointerActive = false; }, { passive: true });
                window.addEventListener('touchcancel', () => { pointerActive = false; }, { passive: true });
                window.addEventListener('touchmove', (e) => {
                    if (!pointerActive) return;
                    if (canvasEl.contains(e.target) || e.target === canvasEl) markInteracting('touchmove');
                }, { passive: true });
                // Keyboard (restrict to camera-affecting keys)
                window.addEventListener('keydown', (e) => {
                    const tag = document.activeElement && document.activeElement.tagName;
                    if (tag && ['INPUT','TEXTAREA','SELECT'].includes(tag)) return;
                    if (['r','w'].includes(e.key.toLowerCase())) markInteracting('key');
                }, { passive: true });
                // OrbitControls change only counts while actively dragging (prevents inertia/damping from flagging)
                if (controls) {
                    controls.addEventListener('change', () => { if (pointerActive) markInteracting('controls'); });
                }
                // Expose for debugging if needed
                window._ahDebugInteraction = () => ({ pointerActive, lastInteractionAt, userInteracting: animationHelper._userInteracting });

                // Keyboard shortcuts for tips
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() === 'r') { window.resetCamera(); }
                    if (e.key.toLowerCase() === 'w') { window.toggleWireframe(); }
                    if (e.key.toLowerCase() === 'h') { document.body.classList.toggle('ui-hidden'); }
                });
                
                updateModelStatus('✅ 3D environment ready!<br/>🎮 Use controls to load and test models.');
                
                // Enable click-to-copy on camera info rows
                setupCameraCopyHandlers();
                
                // Set up minimize button click handlers
                setupMinimizeButtons();
                
                // Fix controls panel pointer events
                setTimeout(() => fixControlsPanel(), 100);
                
                // Debug: Check current UI mode states
                console.log('🐛 UI States after init:', {
                    uiHidden: document.body.classList.contains('ui-hidden'),
                    bodyClasses: Array.from(document.body.classList)
                });
                
            } catch (error) {
                console.error('Init error:', error);
                updateModelStatus(`❌ Initialization failed:<br/>${error.message}`, true);
            }
        }
        
        // Panel minimize/maximize functionality
        window.testControlsPanel = function() {
            console.log('🧪 Testing controls panel...');
            
            // Test if elements exist
            const singleBtn = document.getElementById('single-mode-btn');
            const comparisonBtn = document.getElementById('comparison-mode-btn');
            const modelSelect = document.getElementById('model-a-select');
            
            console.log('Elements found:', {
                singleBtn: !!singleBtn,
                comparisonBtn: !!comparisonBtn,
                modelSelect: !!modelSelect
            });
            
            if (singleBtn) {
                console.log('Single btn onclick:', singleBtn.onclick ? 'exists' : 'MISSING');
                console.log('Single btn getAttribute onclick:', singleBtn.getAttribute('onclick'));
            }
            
            // Try to programmatically trigger setMode
            if (window.setMode) {
                console.log('setMode function exists, testing...');
                try {
                    window.setMode('comparison');
                    console.log('✅ setMode(comparison) successful');
                } catch (e) {
                    console.error('❌ setMode failed:', e);
                }
            } else {
                console.error('❌ setMode function not found');
            }
        };

        window.debugPanelStates = function() {
            console.log('🐛 Panel Debug Info:');
            console.log('Body classes:', Array.from(document.body.classList));
            console.log('UI hidden mode:', document.body.classList.contains('ui-hidden'));
            
            const panels = [
                'model-status-panel',
                'camera-panel', 
                'animation-helper-panel',
                'performance-panel',
                'controls-panel'
            ];
            
            panels.forEach(id => {
                const panel = document.getElementById(id);
                if (panel) {
                    const computedStyle = window.getComputedStyle(panel);
                    console.log(`${id}:`, {
                        pointerEvents: computedStyle.pointerEvents,
                        display: computedStyle.display,
                        visibility: computedStyle.visibility
                    });
                }
            });
            
            // Test controls panel elements
            const selects = document.querySelectorAll('#controls-panel select');
            const buttons = document.querySelectorAll('#controls-panel button');
            console.log(`Controls panel: ${selects.length} selects, ${buttons.length} buttons`);
            selects.forEach((select, i) => {
                const style = window.getComputedStyle(select);
                console.log(`Select ${i}:`, {
                    pointerEvents: style.pointerEvents,
                    disabled: select.disabled
                });
            });
        };

        window.togglePanel = function(panelId) {
            const panel = document.getElementById(panelId);
            const content = panel.querySelector('.panel-content');
            const btn = panel.querySelector('.minimize-btn');
            
            if (content.classList.contains('minimized')) {
                // Expand
                content.classList.remove('minimized');
                panel.classList.remove('minimized');
                btn.textContent = '−';
                btn.title = 'Minimize panel';
            } else {
                // Minimize
                content.classList.add('minimized');
                panel.classList.add('minimized');
                btn.textContent = '+';
                btn.title = 'Expand panel';
            }
        };
        
        // Model toggle function for comparison mode
        window.toggleToModel = function(modelLetter) {
            if (!isComparisonMode) return;
            
            const toggleA = document.getElementById('model-a-toggle');
            const toggleB = document.getElementById('model-b-toggle');
            const selectA = document.getElementById('model-a-select');
            const selectB = document.getElementById('model-b-select');
            
            // Update toggle visual state
            toggleA.classList.toggle('active', modelLetter === 'A');
            toggleB.classList.toggle('active', modelLetter === 'B');
            
            // Save current camera position before clearing models
            const savedCameraPosition = camera.position.clone();
            const savedCameraTarget = controls.target.clone();
            
            // Clear existing models
            clearAllModels();
            
            if (modelLetter === 'A') {
                // Show only Model A
                const modelAKey = selectA.value;
                const modelAInfo = availableModels.find(m => m.key === modelAKey);
                if (modelAInfo) {
                    updateModelStatus(`🔄 Loading Model A: ${modelAInfo.name}...`);
                    loadModelForComparison(modelAKey, 'Model A').then(result => {
                        modelA = result.model;
                        modelB = null;
                        setupSingleModelWithCamera(modelA, savedCameraPosition, savedCameraTarget);
                        updateModelStatus(`✅ Model A loaded: ${modelAInfo.name}<br/>📦 ${result.meshCount} meshes | ${result.loadTime}s`);
                    }).catch(error => {
                        updateModelStatus(`❌ Failed to load Model A: ${error.message}`, true);
                    });
                }
            } else {
                // Show only Model B  
                const modelBKey = selectB.value;
                const modelBInfo = availableModels.find(m => m.key === modelBKey);
                if (modelBInfo) {
                    updateModelStatus(`🔄 Loading Model B: ${modelBInfo.name}...`);
                    loadModelForComparison(modelBKey, 'Model B').then(result => {
                        modelB = result.model;
                        modelA = null;
                        setupSingleModelWithCamera(modelB, savedCameraPosition, savedCameraTarget);
                        updateModelStatus(`✅ Model B loaded: ${modelBInfo.name}<br/>📦 ${result.meshCount} meshes | ${result.loadTime}s`);
                    }).catch(error => {
                        updateModelStatus(`❌ Failed to load Model B: ${error.message}`, true);
                    });
                }
            }
        };
        
        // Setup single model in comparison mode (preserves existing camera position)
        function setupSingleModel(model) {
            if (!model) return;
            
            // Calculate bounding box and scale
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxSize = Math.max(size.x, size.y, size.z);
            const scale = 100 / maxSize;
            
            // Scale and center the model
            model.scale.setScalar(scale);
            const center = box.getCenter(new THREE.Vector3());
            model.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
            
            // Add to scene
            scene.add(model);
            
            // Position camera for good view (only if camera hasn't been positioned yet)
            if (!camera.position.length()) {
                const idealDistance = maxSize * scale * 1.5;
                camera.position.set(idealDistance * 0.5, idealDistance * 0.3, idealDistance);
                camera.lookAt(0, 0, 0);
            }
            controls.update();
        }
        
        // Setup single model with saved camera position
        function setupSingleModelWithCamera(model, savedPosition, savedTarget) {
            if (!model) return;
            
            // Calculate bounding box and scale
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxSize = Math.max(size.x, size.y, size.z);
            const scale = 100 / maxSize;
            
            // Scale and center the model
            model.scale.setScalar(scale);
            const center = box.getCenter(new THREE.Vector3());
            model.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
            
            // Add to scene
            scene.add(model);
            
            // Restore saved camera position
            camera.position.copy(savedPosition);
            controls.target.copy(savedTarget);
            camera.lookAt(savedTarget);
            controls.update();
        }
        
        // Global functions
        window.loadModel = loadModel;
        window.setMode = setMode;
        window.loadBothModels = loadBothModels;
        window.updateOpacity = updateOpacity;
        window.swapModels = swapModels;
        window.loadPreset = loadPreset;
        
        window.resetCamera = function() {
            if (camera && controls) {
                camera.position.set(-23.8, 69.2, 89.3);
                controls.target.set(3.5, -35.4, -14.7);
                camera.lookAt(3.5, -35.4, -14.7);
                if (typeof controls.saveState === 'function') controls.saveState();
                controls.update();
                updateModelStatus('📷 Camera reset to default position');
            }
        };
        
        window.toggleWireframe = function() {
            if (currentModel) {
                let wireframe = false;
                currentModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.wireframe = !child.material.wireframe;
                        wireframe = child.material.wireframe;
                    }
                });
                updateModelStatus(`🔧 Wireframe mode: ${wireframe ? 'ON' : 'OFF'}`);
            }
        };
        
        // Reusable safe copy helper with fallback for non-secure contexts
        async function safeCopy(text) {
            console.log('[safeCopy] Attempting to copy:', text.slice(0, 50) + '...');
            
            // 1. Modern API (must be secure context: https or localhost)
            if (navigator.clipboard && window.isSecureContext) {
                try {
                    await navigator.clipboard.writeText(text);
                    console.log('[safeCopy] ✅ Clipboard API success');
                    return true;
                } catch (err) {
                    console.warn('[safeCopy] navigator.clipboard failed, falling back', err);
                }
            } else {
                console.log('[safeCopy] Clipboard API not available (secure context:', window.isSecureContext, 'clipboard:', !!navigator.clipboard, ')');
            }
            
            // 2. Old IE / Edge HTML clipboardData
            try {
                if (window.clipboardData && window.clipboardData.setData) {
                    const result = window.clipboardData.setData('Text', text);
                    console.log('[safeCopy] clipboardData result:', result);
                    return result;
                }
            } catch (err) { 
                console.warn('[safeCopy] clipboardData failed', err);
            }
            
            // 3. execCommand fallback (must occur during a user gesture to be reliable)
            try {
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.opacity = '0';
                ta.style.pointerEvents = 'none';
                document.body.appendChild(ta);
                ta.focus({ preventScroll: true });
                ta.select();
                ta.setSelectionRange(0, ta.value.length);
                const ok = document.execCommand('copy');
                document.body.removeChild(ta);
                console.log('[safeCopy] execCommand result:', ok);
                if (ok) return true;
            } catch (err) {
                console.warn('[safeCopy] execCommand fallback failed', err);
            }
            
            console.error('[safeCopy] ❌ All clipboard methods failed');
            return false;
        }

        window.copyCurrentPosition = async function() {
            if (!(camera && controls)) return;
            const pos = camera.position;
            const target = controls.target;
            const jsCode = `// Camera position for Webflow\n`+
`camera.position.set(${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)});\n`+
`camera.lookAt(${target.x.toFixed(1)}, ${target.y.toFixed(1)}, ${target.z.toFixed(1)});\n`+
`controls.target.set(${target.x.toFixed(1)}, ${target.y.toFixed(1)}, ${target.z.toFixed(1)});`;
            const ok = await safeCopy(jsCode);
            if (ok) {
                updateModelStatus('📋 Camera position copied to clipboard!<br/>Ready to paste into your production code.');
                showToast('Camera code copied');
            } else {
                updateModelStatus('⚠️ Copy failed. Select & copy manually below:<br/><pre style="font-size:11px;white-space:pre-wrap;max-height:120px;overflow:auto;">'+jsCode.replace(/[<>]/g,m=>({'<':'&lt;','>':'&gt;'}[m]))+'</pre>');
                showToast('Copy failed');
            }
        };

        function showToast(message) {
            const toast = document.getElementById('toast');
            if (!toast) return;
            toast.textContent = message;
            toast.classList.add('show');
            clearTimeout(showToast._t);
            showToast._t = setTimeout(() => {
                toast.classList.remove('show');
            }, 1500);
        }

        function setupCameraCopyHandlers() {
            // Set up camera panel copyable rows
            const cameraRows = document.querySelectorAll('#camera-panel .camera-info div');
            cameraRows.forEach((row) => {
                row.style.cursor = 'pointer';
                row.title = 'Click to copy';
                row.classList.add('copyable');
                row.addEventListener('click', async () => {
                    const labelNode = row.childNodes[0];
                    const label = labelNode ? String(labelNode.textContent || '').replace(':','').trim() : 'Value';
                    const span = row.querySelector('span');
                    const value = span ? span.textContent.trim() : row.textContent.trim();
                    const text = `${label}: ${value}`;
                    const ok = await safeCopy(text);
                    showToast(ok ? `${label} copied` : 'Copy failed');
                });
            });
            
            // Set up model status panel as copyable
            const modelStatus = document.getElementById('model-status');
            if (modelStatus) {
                modelStatus.style.cursor = 'pointer';
                modelStatus.title = 'Click to copy model status';
                modelStatus.classList.add('copyable');
                modelStatus.addEventListener('click', async () => {
                    const text = modelStatus.textContent || modelStatus.innerText || '';
                    const ok = await safeCopy(text.trim());
                    showToast(ok ? 'Model status copied' : 'Copy failed');
                });
            }
        }
        
        function setupMinimizeButtons() {
            // Set up minimize button handlers for panels that don't have inline onclick
            const buttons = [
                { id: 'tips-btn', panelId: 'tips-panel' },
                { id: 'model-status-btn', panelId: 'model-status-panel' },
                { id: 'camera-btn', panelId: 'camera-panel' },
                { id: 'animation-helper-btn', panelId: 'animation-helper-panel' },
                { id: 'performance-btn', panelId: 'performance-panel' }
            ];
            
            buttons.forEach(({ id, panelId }) => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        togglePanel(panelId);
                    };
                }
            });
        }

        function fixControlsPanel() {
            console.log('🔧 Fixing controls panel...');
            
            // Get the controls panel and log its state
            const controlsPanel = document.getElementById('controls-panel');
            if (!controlsPanel) {
                console.error('❌ Controls panel not found!');
                return;
            }
            
            const style = window.getComputedStyle(controlsPanel);
            console.log('Controls panel computed styles:', {
                pointerEvents: style.pointerEvents,
                zIndex: style.zIndex,
                position: style.position,
                display: style.display
            });
            
            // Force enable pointer events on the entire panel
            controlsPanel.style.pointerEvents = 'auto';
            
            // Check and fix all interactive elements
            const selects = controlsPanel.querySelectorAll('select');
            const buttons = controlsPanel.querySelectorAll('button');
            const toggles = controlsPanel.querySelectorAll('.toggle-option');
            const inputs = controlsPanel.querySelectorAll('input');
            
            console.log(`Found: ${selects.length} selects, ${buttons.length} buttons, ${toggles.length} toggles, ${inputs.length} inputs`);
            
            // Force enable pointer events on all interactive elements
            [...selects, ...buttons, ...toggles, ...inputs].forEach(el => {
                el.style.pointerEvents = 'auto';
                el.style.cursor = 'pointer';
            });
            
            // Test click handlers
            toggles.forEach((toggle, i) => {
                const currentHandler = toggle.onclick;
                console.log(`Toggle ${i} onclick:`, currentHandler ? 'has handler' : 'NO HANDLER');
            });
            
            console.log('✅ Controls panel fix complete');
        }
        
        window.showFullDebugInfo = function() {
            const info = [];
            
            if (camera && controls) {
                const pos = camera.position;
                const target = controls.target;
                info.push(`📍 CAMERA POSITION:`);
                info.push(`Position: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);
                info.push(`Target: (${target.x.toFixed(2)}, ${target.y.toFixed(2)}, ${target.z.toFixed(2)})`);
                info.push(`Distance: ${pos.distanceTo(target).toFixed(2)}`);
                info.push(``);
            }
            
            if (renderer) {
                const rInfo = renderer.info;
                info.push(`⚡ PERFORMANCE:`);
                info.push(`FPS: ${performanceMonitor.fps}`);
                info.push(`Triangles: ${rInfo.render.triangles.toLocaleString()}`);
                info.push(`Draw Calls: ${rInfo.render.calls}`);
                info.push(`Geometries: ${rInfo.memory.geometries}`);
                info.push(`Textures: ${rInfo.memory.textures}`);
                info.push(``);
            }
            
            info.push(`🌐 SYSTEM:`);
            info.push(`Three.js: r${THREE.REVISION}`);
            info.push(`WebGL: ${renderer.capabilities.isWebGL2 ? '2.0' : '1.0'}`);
            info.push(`Max Texture Size: ${renderer.capabilities.maxTextureSize}`);
            info.push(`Screen: ${window.innerWidth}x${window.innerHeight}`);
            info.push(`Device Pixel Ratio: ${window.devicePixelRatio}`);
            
            alert(info.join('\n'));
        };
        
        // Initialize
        updateModelStatus('🚀 Starting enhanced 3D map environment...');
        initMap();
        
        // Animation helper object and easing functions are declared above with other globals
        
        function totalDuration() {
            return animationHelper.durations.reduce((a,b)=>a+b, 0) || 0;
        }

        function fmtVec(v) { return `${v.x.toFixed(1)},${v.y.toFixed(1)},${v.z.toFixed(1)}`; }

        function addKeyframe() {
            if (!camera || !controls) return;
            const kf = {
                id: Date.now() + Math.random(),
                position: camera.position.clone(),
                target: controls.target.clone(),
                timestamp: Date.now()
            };
            animationHelper.keyframes.push(kf);
            const count = animationHelper.keyframes.length;
            if (count > 1 && animationHelper.durations.length < count - 1) {
                animationHelper.durations.push(2000); // default 2s segment
            }
            status(`Keyframe ${count} added.`);
            updateKeyframeList();
            document.getElementById('kf-reset-view').disabled = animationHelper.keyframes.length === 0;
        }

        function removeKeyframe(id) {
            if (animationHelper.playing) return;
            const idx = animationHelper.keyframes.findIndex(k => k.id === id);
            if (idx === -1) return;
            animationHelper.keyframes.splice(idx,1);
            if (idx < animationHelper.durations.length) {
                animationHelper.durations.splice(idx,1); // remove corresponding segment
            } else if (idx === animationHelper.keyframes.length) {
                animationHelper.durations.pop();
            }
            status('Keyframe removed.');
            updateKeyframeList();
            if (animationHelper.keyframes.length === 0) {
                document.getElementById('kf-reset-view').disabled = true;
            }
        }

        // Helper function to update progress display
        function updateProgress(value) {
            const progressFill = document.getElementById('kf-progress-fill');
            if (progressFill) {
                progressFill.style.width = (value * 100) + '%';
            }
        }
        
        // Helper function to update keyframe count display
        function updateKeyframeCount() {
            const countEl = document.getElementById('keyframe-count');
            if (countEl) {
                const count = animationHelper.keyframes.length;
                countEl.textContent = count + ' keyframe' + (count !== 1 ? 's' : '');
            }
        }

        function clearKeyframes() {
            if (animationHelper.playing) return;
            animationHelper.keyframes = [];
            animationHelper.durations = [];
            animationHelper.elapsedBeforePause = 0;
            animationHelper.playing = false;
            animationHelper.paused = false;
            updateKeyframeList();
            updateProgress(0);
            document.getElementById('kf-scrub').value = 0;
            document.getElementById('kf-time').textContent = '0.0s';
            document.getElementById('kf-play').disabled = true;
            document.getElementById('kf-pause').disabled = true;
            document.getElementById('kf-stop').disabled = true;
            document.getElementById('kf-reset-view').disabled = true;
            updateKeyframeCount();
            status('All keyframes cleared.');
        }

        function updateKeyframeList() {
            const list = document.getElementById('kf-list');
            const empty = document.getElementById('kf-empty');
            
            // Clear existing keyframes
            list.querySelectorAll('.keyframe-item').forEach(item => item.remove());
            
            const k = animationHelper.keyframes;
            empty.style.display = k.length === 0 ? 'block' : 'none';
            
            k.forEach((kf, i) => {
                const item = document.createElement('div');
                item.className = 'keyframe-item';
                
                const header = document.createElement('div');
                header.className = 'keyframe-header';
                
                const title = document.createElement('div');
                title.className = 'keyframe-title';
                title.textContent = `Keyframe ${i + 1}`;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'keyframe-remove';
                removeBtn.innerHTML = '🗑️';
                removeBtn.title = 'Remove keyframe';
                removeBtn.addEventListener('click', () => removeKeyframe(kf.id));
                
                header.appendChild(title);
                header.appendChild(removeBtn);
                
                const details = document.createElement('div');
                details.className = 'keyframe-details';
                details.innerHTML = `
                    <div>Position: ${fmtVec(kf.position)}</div>
                    <div>Target: ${fmtVec(kf.target)}</div>
                `;
                
                item.appendChild(header);
                item.appendChild(details);
                
                // Add segment duration settings (except for last keyframe)
                if (i < k.length - 1) {
                    const segmentDiv = document.createElement('div');
                    segmentDiv.className = 'segment-settings';
                    segmentDiv.style.marginTop = '8px';
                    segmentDiv.style.paddingTop = '8px';
                    segmentDiv.style.borderTop = '1px solid rgba(75, 85, 99, 0.3)';
                    
                    const label = document.createElement('span');
                    label.innerHTML = `→ KF ${i+2} duration`;
                    label.style.fontSize = '11px';
                    label.style.color = '#9CA3AF';
                    label.style.marginRight = '8px';
                    
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = '100';
                    input.step = '100';
                    input.value = animationHelper.durations[i] || 2000;
                    input.title = 'Segment duration (ms)';
                    input.style.width = '80px';
                    input.style.padding = '4px 6px';
                    input.style.fontSize = '11px';
                    input.style.background = 'rgba(55, 65, 81, 0.6)';
                    input.style.border = '1px solid rgba(75, 85, 99, 0.4)';
                    input.style.borderRadius = '4px';
                    input.style.color = '#F3F4F6';
                    
                    input.addEventListener('change', () => {
                        const v = parseInt(input.value) || 1000;
                        animationHelper.durations[i] = Math.max(50, v);
                        status(`Segment ${i+1} duration set to ${animationHelper.durations[i]} ms`);
                    });
                    
                    segmentDiv.appendChild(label);
                    segmentDiv.appendChild(input);
                    item.appendChild(segmentDiv);
                }
                
                list.appendChild(item);
            });
            
            const canPlay = animationHelper.keyframes.length >= 2 && !animationHelper.playing;
            document.getElementById('kf-play').disabled = !canPlay;
            document.getElementById('kf-stop').disabled = animationHelper.keyframes.length < 2;
            document.getElementById('kf-reset-view').disabled = animationHelper.keyframes.length === 0;
            updateKeyframeCount();
        }

        function lerp(a, b, t) { return a + (b - a) * t; }
        function lerpVec(a, b, t) { return new THREE.Vector3( lerp(a.x,b.x,t), lerp(a.y,b.y,t), lerp(a.z,b.z,t) ); }

        function evaluatePath(tNorm) {
            // tNorm in [0,1]
            const k = animationHelper.keyframes;
            if (k.length === 0) return null;
            if (k.length === 1) return { position: k[0].position.clone(), target: k[0].target.clone() };
            const total = totalDuration();
            if (!total) return { position: k[0].position.clone(), target: k[0].target.clone() };
            const tAbs = tNorm * total;
            let acc = 0;
            for (let i=0; i<k.length-1; i++) {
                const segDur = animationHelper.durations[i];
                if (tAbs <= acc + segDur || i === k.length-2) {
                    const localT = Math.min(1, (tAbs - acc) / segDur);
                    const ease = EASING[animationHelper.easing] || EASING.linear;
                    const et = ease(localT);
                    return {
                        position: lerpVec(k[i].position, k[i+1].position, et),
                        target: lerpVec(k[i].target, k[i+1].target, et)
                    };
                }
                acc += segDur;
            }
            return { position: k[k.length-1].position.clone(), target: k[k.length-1].target.clone() };
        }

        function applyPathSample(sample) {
            if (!sample) return;
            // Skip applying if user is actively interacting (prevents fighting controls)
            if (animationHelper._userInteracting) return;
            camera.position.copy(sample.position);
            controls.target.copy(sample.target);
            camera.lookAt(sample.target);
            controls.update();
        }

        function playAnimation() {
            console.log('playAnimation called, keyframes:', animationHelper.keyframes.length, 'playing:', animationHelper.playing);
            if (animationHelper.keyframes.length < 2 || animationHelper.playing) return;
            console.log('Starting animation playback...');
            animationHelper.suppressNextInteraction = true; // ignore the click
            setTimeout(() => { animationHelper.suppressNextInteraction = false; }, 150);
            animationHelper._userInteracting = false;
            animationHelper.playing = true;
            animationHelper.paused = false;
            animationHelper.startTime = performance.now();
            animationHelper.interactionGraceUntil = animationHelper.startTime + 500; // grace period: prior drags won't cancel
            animationHelper.elapsedBeforePause = 0;
            document.getElementById('kf-play').disabled = true;
            document.getElementById('kf-pause').disabled = false;
            document.getElementById('kf-stop').disabled = false;
            status('Playing animation...');
            animatePlayback();
        }

        function pauseAnimation() {
            console.log('pauseAnimation called, playing:', animationHelper.playing, 'paused:', animationHelper.paused);
            if (!animationHelper.playing) return;
            if (!animationHelper.paused) {
                console.log('Pausing animation...');
                animationHelper.paused = true;
                animationHelper.elapsedBeforePause += performance.now() - animationHelper.startTime;
                if (animationHelper.rafId) cancelAnimationFrame(animationHelper.rafId);
                status('Paused.');
                document.getElementById('kf-pause').textContent = '▶️';
            } else {
                console.log('Resuming animation...');
                animationHelper.paused = false;
                animationHelper.startTime = performance.now();
                status('Resuming...');
                document.getElementById('kf-pause').textContent = '⏸️';
                animatePlayback();
            }
        }

        function stopAnimation() {
            if (animationHelper.rafId) cancelAnimationFrame(animationHelper.rafId);
            animationHelper.playing = false;
            animationHelper.paused = false;
            animationHelper.elapsedBeforePause = 0;
            document.getElementById('kf-play').disabled = animationHelper.keyframes.length < 2;
            document.getElementById('kf-pause').disabled = true;
            document.getElementById('kf-pause').textContent = '⏸️';
            document.getElementById('kf-stop').disabled = animationHelper.keyframes.length < 2;
            updateProgress(0);
            document.getElementById('kf-scrub').value = 0;
            document.getElementById('kf-time').textContent = '0.0s';
            if (animationHelper.keyframes[0]) applyPathSample({ position: animationHelper.keyframes[0].position, target: animationHelper.keyframes[0].target });
            status('Stopped.');
        }

        function animatePlayback() {
            const progressFillEl = document.getElementById('kf-progress-fill');
            const scrubEl = document.getElementById('kf-scrub');
            const timeEl = document.getElementById('kf-time');
            const total = totalDuration();
            let interactingFrames = 0; // consecutive frames seen as interacting
            const step = (now) => {
                if (!animationHelper.playing || animationHelper.paused) return;
                // Respect grace window after pressing Play
                const withinGrace = animationHelper.interactionGraceUntil && now < animationHelper.interactionGraceUntil;
                if (animationHelper._userInteracting && !withinGrace) {
                    interactingFrames++;
                    if (interactingFrames >= 4) { // require sustained interaction (~4 rAF frames)
                        stopAnimation();
                        status('Animation stopped by user interaction.');
                        return;
                    }
                } else {
                    interactingFrames = 0;
                }
                const elapsed = animationHelper.elapsedBeforePause + (now - animationHelper.startTime);
                const clamped = Math.min(elapsed, total);
                const tNorm = total ? clamped / total : 0;
                if (progressFillEl) progressFillEl.style.width = (tNorm * 100) + '%';
                scrubEl.value = tNorm;
                timeEl.textContent = (clamped/1000).toFixed(1)+'s';
                applyPathSample(evaluatePath(tNorm));
                if (clamped >= total) {
                    animationHelper.playing = false;
                    document.getElementById('kf-play').disabled = false;
                    document.getElementById('kf-pause').disabled = true;
                    status('Animation complete.');
                } else {
                    animationHelper.rafId = requestAnimationFrame(step);
                }
            };
            animationHelper.rafId = requestAnimationFrame(step);
        }

        function scrubTo(tNorm, fromUser=false) {
            if (fromUser && animationHelper.playing) {
                // Stop playback if user scrubs
                stopAnimation();
            }
            tNorm = Math.min(1, Math.max(0, tNorm));
            updateProgress(tNorm);
            document.getElementById('kf-scrub').value = tNorm;
            const total = totalDuration();
            document.getElementById('kf-time').textContent = (tNorm * total / 1000).toFixed(1)+'s';
            applyPathSample(evaluatePath(tNorm));
        }

        function status(msg) {
            const el = document.getElementById('kf-status');
            if (el) el.textContent = msg;
        }

        function resetViewToFirst() {
            if (animationHelper.keyframes[0]) {
                applyPathSample(animationHelper.keyframes[0]);
                updateProgress(0);
                document.getElementById('kf-scrub').value = 0;
                document.getElementById('kf-time').textContent = '0.0s';
                status('Moved to first keyframe.');
            }
        }

        let animationHelperInitialized = false;

        function initAnimationHelperUI() {
            // Prevent multiple initializations
            if (animationHelperInitialized) {
                console.log('Animation helper already initialized');
                return;
            }
            
            const addBtn = document.getElementById('kf-add');
            const clearBtn = document.getElementById('kf-clear');
            const playBtn = document.getElementById('kf-play');
            const pauseBtn = document.getElementById('kf-pause');
            const stopBtn = document.getElementById('kf-stop');
            const easeSelect = document.getElementById('kf-ease');
            const scrub = document.getElementById('kf-scrub');
            const resetBtn = document.getElementById('kf-reset-view');
            // Phase 3 elements
            const saveBtn = document.getElementById('anim-save');
            const nameInput = document.getElementById('anim-name');
            const listSelect = document.getElementById('anim-list');
            const loadBtn = document.getElementById('anim-load');
            const renameBtn = document.getElementById('anim-rename');
            const deleteBtn = document.getElementById('anim-delete');
            const refreshBtn = document.getElementById('anim-refresh');
            
            // Check if all required elements exist
            if (!addBtn || !clearBtn || !playBtn || !pauseBtn || !stopBtn) {
                console.warn('Animation helper UI elements not found, retrying...');
                setTimeout(initAnimationHelperUI, 200);
                return;
            }
            
            console.log('Initializing animation helper UI...');
            
            addBtn.addEventListener('click', addKeyframe);
            clearBtn.addEventListener('click', clearKeyframes);
            console.log('Attaching play/pause event listeners...');
            playBtn.addEventListener('click', playAnimation);
            pauseBtn.addEventListener('click', pauseAnimation);
            stopBtn.addEventListener('click', stopAnimation);
            console.log('Play/pause event listeners attached');
            if (resetBtn) resetBtn.addEventListener('click', resetViewToFirst);
            easeSelect.addEventListener('change', () => {
                animationHelper.easing = easeSelect.value;
                status(`Easing set to ${easeSelect.value}`);
            });
            scrub.addEventListener('input', (e) => scrubTo(parseFloat(e.target.value), true));
            // Enable save when there are >=2 keyframes
            const updateSaveState = () => { saveBtn.disabled = animationHelper.keyframes.length < 2; };
            const origUpdateKF = updateKeyframeList;
            updateKeyframeList = function() { origUpdateKF(); updateSaveState(); };
            // Persistence logic
            refreshBtn.addEventListener('click', populateSavedAnimations);
            saveBtn.addEventListener('click', () => {
                const name = (nameInput.value || '').trim();
                if (!name) { status('Enter a name before saving.'); return; }
                saveCurrentAnimation(name);
            });
            loadBtn.addEventListener('click', () => {
                const sel = listSelect.value; if (!sel) return; loadAnimation(sel); });
            renameBtn.addEventListener('click', () => {
                const sel = listSelect.value; if (!sel) return;
                const newName = prompt('New animation name:', sel);
                if (newName && newName.trim() && newName !== sel) { renameAnimation(sel, newName.trim()); }
            });
            deleteBtn.addEventListener('click', () => {
                const sel = listSelect.value; if (!sel) return;
                if (confirm(`Delete animation "${sel}"?`)) { deleteAnimation(sel); }
            });
            listSelect.addEventListener('change', () => {
                const has = !!listSelect.value;
                loadBtn.disabled = !has;
                renameBtn.disabled = !has;
                deleteBtn.disabled = !has;
            });
            populateSavedAnimations();
            updateKeyframeList();
            
            // Mark as initialized
            animationHelperInitialized = true;
            console.log('Animation helper UI initialized successfully');
        }

        // ---- Phase 3 persistence helpers ----
        const STORAGE_KEY = 'animationHelperLibrary_v1';

        function loadLibrary() {
            try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); } catch { return {}; }
        }
        function saveLibrary(lib) {
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify(lib)); } catch (e) { console.warn('Persist failed', e); }
        }
        function serializeCurrent() {
            return {
                keyframes: animationHelper.keyframes.map(k => ({
                    position: { x:k.position.x, y:k.position.y, z:k.position.z },
                    target: { x:k.target.x, y:k.target.y, z:k.target.z },
                    timestamp: k.timestamp
                })),
                durations: [...animationHelper.durations],
                easing: animationHelper.easing,
                savedAt: Date.now()
            };
        }
        function deserializeInto(data) {
            if (!data) return;
            animationHelper.keyframes = data.keyframes.map(k => ({
                id: Date.now()+Math.random(),
                position: new THREE.Vector3(k.position.x, k.position.y, k.position.z),
                target: new THREE.Vector3(k.target.x, k.target.y, k.target.z),
                timestamp: k.timestamp || Date.now()
            }));
            animationHelper.durations = Array.isArray(data.durations) ? data.durations.slice() : [];
            animationHelper.easing = data.easing || 'linear';
            document.getElementById('kf-ease').value = animationHelper.easing;
            updateKeyframeList();
            scrubTo(0);
            status('Animation loaded.');
        }
        function saveCurrentAnimation(name) {
            const lib = loadLibrary();
            lib[name] = serializeCurrent();
            saveLibrary(lib);
            populateSavedAnimations(name);
            status(`Saved animation "${name}".`);
        }
        function loadAnimation(name) {
            const lib = loadLibrary();
            if (!lib[name]) { status('Animation not found.'); return; }
            deserializeInto(lib[name]);
        }
        function renameAnimation(oldName, newName) {
            const lib = loadLibrary();
            if (!lib[oldName]) { status('Animation not found.'); return; }
            if (lib[newName]) { status('Name already exists.'); return; }
            lib[newName] = lib[oldName];
            delete lib[oldName];
            saveLibrary(lib);
            populateSavedAnimations(newName);
            status(`Renamed to "${newName}".`);
        }
        function deleteAnimation(name) {
            const lib = loadLibrary();
            if (lib[name]) { delete lib[name]; saveLibrary(lib); }
            populateSavedAnimations();
            status(`Deleted "${name}".`);
        }
        function populateSavedAnimations(selectName='') {
            const listSelect = document.getElementById('anim-list');
            if (!listSelect) return;
            const lib = loadLibrary();
            const names = Object.keys(lib).sort((a,b)=>a.localeCompare(b));
            listSelect.innerHTML = '<option value="">(none)</option>' + names.map(n=>`<option value="${n}">${n}</option>`).join('');
            
            // Default to "intro" if no specific selection and "intro" exists
            if (!selectName && names.includes('intro')) {
                selectName = 'intro';
            }
            
            listSelect.value = names.includes(selectName) ? selectName : '';
            const has = !!listSelect.value;
            document.getElementById('anim-load').disabled = !has;
            document.getElementById('anim-rename').disabled = !has;
            document.getElementById('anim-delete').disabled = !has;
            
            // If "intro" is selected, load it automatically
            if (listSelect.value === 'intro') {
                loadAnimation('intro');
            }
        }

        setTimeout(initAnimationHelperUI, 500);

        // Auto-discover models after initialization
        setTimeout(discoverModels, 1200);
        
        // =============================
        // 🔧 Configuration Export/Import System (Phase 2 Tasks 2.1-2.5)
        // =============================
        
        // Initialize configuration system
        function initConfigurationSystem() {
            const exportBtn = document.getElementById('config-export');
            const previewBtn = document.getElementById('config-preview');
            const importFileInput = document.getElementById('config-import-file');
            const importBtn = document.getElementById('config-import-btn');
            const loadBtn = document.getElementById('config-load');
            const pushBtn = document.getElementById('config-push');
            const pushStatus = document.getElementById('push-status');
            
            if (!exportBtn || !previewBtn || !importFileInput || !importBtn || !loadBtn || !pushBtn) {
                console.warn('Configuration controls not found, retrying...');
                setTimeout(initConfigurationSystem, 200);
                return;
            }
            
            // Export Configuration
            exportBtn.addEventListener('click', exportConfiguration);
            
            // Preview Configuration
            previewBtn.addEventListener('click', previewConfiguration);
            
            // Import Configuration File Selection
            importBtn.addEventListener('click', () => importFileInput.click());
            
            // Handle file selection
            importFileInput.addEventListener('change', handleConfigFileSelection);
            
            // Load Configuration
            loadBtn.addEventListener('click', loadConfiguration);
            
            // Push to Production (with PIN protection)
            pushBtn.addEventListener('click', pushToProductionWithPIN);
            
            console.log('Configuration system initialized');
        }
        
        // Export current configuration as JSON
        function exportConfiguration() {
            try {
                const config = generateCurrentConfiguration();
                const jsonString = JSON.stringify(config, null, 2);
                
                // Create and download file
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `3d-config-${new Date().toISOString().slice(0, 16).replace('T', '_').replace(':', '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showToast('✅ Configuration exported successfully!', 'success');
                console.log('Configuration exported:', config);
            } catch (error) {
                console.error('Failed to export configuration:', error);
                showToast('❌ Failed to export configuration', 'error');
            }
        }
        
        // Preview configuration JSON
        function previewConfiguration() {
            try {
                const config = generateCurrentConfiguration();
                const jsonString = JSON.stringify(config, null, 2);
                
                const previewArea = document.getElementById('config-preview-area');
                const jsonDisplay = document.getElementById('config-json-display');
                
                if (previewArea && jsonDisplay) {
                    jsonDisplay.textContent = jsonString;
                    previewArea.style.display = previewArea.style.display === 'none' ? 'block' : 'none';
                    
                    // Update button text
                    const previewBtn = document.getElementById('config-preview');
                    if (previewBtn) {
                        const isVisible = previewArea.style.display === 'block';
                        previewBtn.innerHTML = `<span class="btn-icon">${isVisible ? '🙈' : '👁️'}</span> ${isVisible ? 'Hide' : 'Preview'} JSON`;
                    }
                }
            } catch (error) {
                console.error('Failed to preview configuration:', error);
                showToast('❌ Failed to preview configuration', 'error');
            }
        }
        
        // Generate configuration from current interface state
        function generateCurrentConfiguration() {
            // Get current camera position
            const cameraPosition = camera ? [
                parseFloat(camera.position.x.toFixed(1)),
                parseFloat(camera.position.y.toFixed(1)),
                parseFloat(camera.position.z.toFixed(1))
            ] : [0, 80, 150];
            
            const cameraTarget = controls ? [
                parseFloat(controls.target.x.toFixed(1)),
                parseFloat(controls.target.y.toFixed(1)),
                parseFloat(controls.target.z.toFixed(1))
            ] : [0, 0, 0];
            
            // Get lighting settings
            const warmEnabled = document.getElementById('warm-enabled')?.checked || false;
            const warmIntensity = parseFloat(document.getElementById('warm-intensity')?.value || 3.9);
            const warmSkyColor = document.getElementById('warm-sky-color')?.value || '#fff5f5';
            const warmGroundColor = document.getElementById('warm-ground-color')?.value || '#bd9a1f';
            
            const mainEnabled = document.getElementById('main-enabled')?.checked || false;
            const mainIntensity = parseFloat(document.getElementById('main-intensity')?.value || 1.0);
            const shadowsEnabled = document.getElementById('shadows-enabled')?.checked || false;
            
            const fillEnabled = document.getElementById('fill-enabled')?.checked || false;
            const fillIntensity = parseFloat(document.getElementById('fill-intensity')?.value || 0.4);
            const fillColor = document.getElementById('fill-color')?.value || '#87ceeb';
            
            const ambientEnabled = document.getElementById('ambient-enabled')?.checked || false;
            const ambientIntensity = parseFloat(document.getElementById('ambient-intensity')?.value || 0.6);
            
            return {
                version: "1.0.0",
                camera: {
                    position: cameraPosition,
                    target: cameraTarget,
                    fov: 60,
                    minDistance: 20,
                    maxDistance: 800
                },
                lighting: {
                    warmAmbient: {
                        enabled: warmEnabled,
                        intensity: warmIntensity,
                        skyColor: warmSkyColor,
                        groundColor: warmGroundColor
                    },
                    mainLight: {
                        enabled: mainEnabled,
                        intensity: mainIntensity,
                        castShadows: shadowsEnabled
                    },
                    fillLight: {
                        enabled: fillEnabled,
                        intensity: fillIntensity,
                        color: fillColor
                    },
                    ambientLight: {
                        enabled: ambientEnabled,
                        intensity: ambientIntensity
                    }
                },
                models: {
                    primary: "goetheviertel"
                },
                animations: {
                    welcomeAnimation: {
                        enabled: true,
                        duration: 1700,
                        easing: "easeInOut"
                    }
                },
                performance: {
                    qualityLevel: "high",
                    targetFPS: 60,
                    enableAntialiasing: true,
                    pixelRatio: Math.min(window.devicePixelRatio || 1, 2)
                },
                ui: {
                    showLoadingProgress: true,
                    enableControls: true,
                    enableZoom: true,
                    enableRotate: true,
                    enablePan: true
                },
                accessibility: {
                    respectMotionPreference: true,
                    keyboardControls: true,
                    ariaLabels: true
                },
                exportedAt: new Date().toISOString()
            };
        }
        
        // Handle configuration file selection
        function handleConfigFileSelection(event) {
            const file = event.target.files[0];
            const fileName = document.getElementById('config-file-name');
            const loadBtn = document.getElementById('config-load');
            
            if (file && fileName && loadBtn) {
                fileName.textContent = file.name;
                loadBtn.disabled = false;
            }
        }
        
        // Load configuration from selected file
        function loadConfiguration() {
            const fileInput = document.getElementById('config-import-file');
            const file = fileInput?.files[0];
            
            if (!file) {
                showToast('❌ Please select a configuration file', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = JSON.parse(e.target.result);
                    applyConfiguration(config);
                    showToast('✅ Configuration loaded successfully!', 'success');
                } catch (error) {
                    console.error('Failed to parse configuration file:', error);
                    showToast('❌ Invalid configuration file format', 'error');
                }
            };
            reader.readAsText(file);
        }
        
        // Apply configuration to current interface
        function applyConfiguration(config) {
            try {
                // Apply camera settings
                if (config.camera && camera && controls) {
                    if (config.camera.position) {
                        camera.position.set(
                            config.camera.position[0],
                            config.camera.position[1],
                            config.camera.position[2]
                        );
                    }
                    if (config.camera.target) {
                        controls.target.set(
                            config.camera.target[0],
                            config.camera.target[1],
                            config.camera.target[2]
                        );
                    }
                    controls.update();
                }
                
                // Apply lighting settings
                if (config.lighting) {
                    const lighting = config.lighting;
                    
                    // Warm ambient light
                    if (lighting.warmAmbient) {
                        const warmEnabled = document.getElementById('warm-enabled');
                        const warmIntensity = document.getElementById('warm-intensity');
                        const warmSkyColor = document.getElementById('warm-sky-color');
                        const warmGroundColor = document.getElementById('warm-ground-color');
                        
                        if (warmEnabled) warmEnabled.checked = lighting.warmAmbient.enabled || false;
                        if (warmIntensity) warmIntensity.value = lighting.warmAmbient.intensity || 3.9;
                        if (warmSkyColor) warmSkyColor.value = lighting.warmAmbient.skyColor || '#fff5f5';
                        if (warmGroundColor) warmGroundColor.value = lighting.warmAmbient.groundColor || '#bd9a1f';
                        
                        if (typeof updateWarmLight === 'function') updateWarmLight();
                    }
                    
                    // Main light
                    if (lighting.mainLight) {
                        const mainEnabled = document.getElementById('main-enabled');
                        const mainIntensity = document.getElementById('main-intensity');
                        const shadowsEnabled = document.getElementById('shadows-enabled');
                        
                        if (mainEnabled) mainEnabled.checked = lighting.mainLight.enabled || false;
                        if (mainIntensity) mainIntensity.value = lighting.mainLight.intensity || 1.0;
                        if (shadowsEnabled) shadowsEnabled.checked = lighting.mainLight.castShadows || false;
                        
                        if (typeof updateMainLight === 'function') updateMainLight();
                        if (typeof updateShadows === 'function') updateShadows();
                    }
                    
                    // Fill light
                    if (lighting.fillLight) {
                        const fillEnabled = document.getElementById('fill-enabled');
                        const fillIntensity = document.getElementById('fill-intensity');
                        const fillColor = document.getElementById('fill-color');
                        
                        if (fillEnabled) fillEnabled.checked = lighting.fillLight.enabled || false;
                        if (fillIntensity) fillIntensity.value = lighting.fillLight.intensity || 0.4;
                        if (fillColor) fillColor.value = lighting.fillLight.color || '#87ceeb';
                        
                        if (typeof updateFillLight === 'function') updateFillLight();
                    }
                    
                    // Ambient light
                    if (lighting.ambientLight) {
                        const ambientEnabled = document.getElementById('ambient-enabled');
                        const ambientIntensity = document.getElementById('ambient-intensity');
                        
                        if (ambientEnabled) ambientEnabled.checked = lighting.ambientLight.enabled || false;
                        if (ambientIntensity) ambientIntensity.value = lighting.ambientLight.intensity || 0.6;
                        
                        if (typeof updateAmbientLight === 'function') updateAmbientLight();
                    }
                }
                
                console.log('Configuration applied successfully:', config);
            } catch (error) {
                console.error('Failed to apply configuration:', error);
                throw error;
            }
        }
        
        // Push configuration with PIN protection
        function pushToProductionWithPIN() {
            // Request PIN verification
            const pin = prompt('🔐 Enter PIN to deploy configuration to Webflow production:');
            
            if (!pin) {
                showToast('❌ Deployment cancelled', 'error');
                return;
            }
            
            if (pin !== '9984') {
                showToast('❌ Invalid PIN. Deployment cancelled.', 'error');
                return;
            }
            
            showToast('✅ PIN verified. Deploying configuration...', 'success');
            
            // Proceed with the actual deployment
            pushToProduction();
        }
        
        // Push configuration to production (now with API integration)
        async function pushToProduction() {
            const pushBtn = document.getElementById('config-push');
            const pushStatus = document.getElementById('push-status');
            const commitMessage = document.getElementById('commit-message')?.value || 'Update 3D configuration from test interface';
            
            if (!pushBtn || !pushStatus) return;
            
            pushBtn.disabled = true;
            pushStatus.style.display = 'block';
            pushStatus.textContent = '🚀 Pushing configuration to GitHub...';
            pushStatus.style.color = '#60A5FA';
            
            try {
                const config = generateCurrentConfiguration();
                
                // Try to push to the development server API
                const response = await fetch('/api/github/commit', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        config: config,
                        commitMessage: commitMessage
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    pushStatus.innerHTML = `
                        ✅ Configuration prepared successfully!<br>
                        <small style="color: #9CA3AF;">
                        ${result.action || 'Configuration saved to src/config/3d-config.json'}<br>
                        Next: Git commit and push to trigger deployment.
                        </small>
                    `;
                    pushStatus.style.color = '#10B981';
                    showToast('✅ Configuration ready for deployment', 'success');
                    
                    // Also copy to clipboard as fallback
                    if (navigator.clipboard) {
                        navigator.clipboard.writeText(JSON.stringify(config, null, 2)).catch(() => {});
                    }
                } else {
                    throw new Error(result.error || 'Failed to prepare configuration');
                }
                
            } catch (error) {
                console.error('Failed to push configuration:', error);
                
                // Fallback to manual process if API fails
                try {
                    const config = generateCurrentConfiguration();
                    const configJson = JSON.stringify(config, null, 2);
                    
                    if (navigator.clipboard) {
                        await navigator.clipboard.writeText(configJson);
                        pushStatus.innerHTML = `
                            ⚠️ API unavailable - Configuration copied to clipboard!<br>
                            <small style="color: #9CA3AF;">
                            Manual step: Create <code>src/config/3d-config.json</code> in your GitHub repo with this content, then push to trigger deployment.
                            </small>
                        `;
                        pushStatus.style.color = '#F59E0B';
                        showToast('📋 Configuration copied to clipboard for manual deployment', 'info');
                    } else {
                        pushStatus.innerHTML = `
                            ❌ Push failed and clipboard unavailable.<br>
                            <small style="color: #9CA3AF;">Use the Export button to download the configuration file manually.</small>
                        `;
                        pushStatus.style.color = '#EF4444';
                        showToast('❌ Push failed - use Export button instead', 'error');
                    }
                } catch (fallbackError) {
                    pushStatus.textContent = '❌ Failed to generate configuration';
                    pushStatus.style.color = '#EF4444';
                    showToast('❌ Configuration generation failed', 'error');
                }
            } finally {
                pushBtn.disabled = false;
            }
        }
        
        // Initialize configuration system
        setTimeout(initConfigurationSystem, 600);
    </script>
</body>
</html>
